.# > name="2- Full agent"
.# > keyword="C"
.# > description="A fully-fledged C agent, ready for industrial use. Compile with Cmake for Windows, Linux, macos, etc."
.# > agentMode="ONE"
.# > onlyAgentDefinitionSupport="true"
.template 0
function typeToCType (type)
   if (type = "STRING")
       return "char *"
   elsif (type = "INTEGER")
       return "int"
   elsif (type = "DOUBLE")
       return "double"
   elsif (type = "BOOL")
       return "bool"
   elsif (type = "IMPULSION")
       return ""
   elsif (type = "DATA")
       return "void *"
   else
        #echo "could not convert type $(type) : return it as is"
       return "$(type)"
   endif
endfunction typeToCType

function typeToIGSType (type)
   if (type = "STRING")
       return "IGS_STRING_T"
   elsif (type = "INTEGER")
       return "IGS_INTEGER_T"
   elsif (type = "DOUBLE")
       return "IGS_DOUBLE_T"
   elsif (type = "BOOL")
       return "IGS_BOOL_T"
   elsif (type = "IMPULSION")
       return "IGS_IMPULSION_T"
   elsif (type = "DATA")
       return "IGS_DATA_T"
   endif
endfunction typeToIGSType

function nameToCName (name)
    return '$("$(name:c)":Neat)'
endfunction nameToCName

.endtemplate
.template 1
.ignorecase = 0
.
.####################################################################################
.echo "Creating directories structure ..."
.directory.create("src")
.directory.create("builds/cmake")
.directory.create("packaging/windows")
.directory.create("packaging/unix")
.
.####################################################################################
.echo "Generating src/main.c ..."
.directory.create("src")
.output "src/main.c"
//
//  main.c
//  $(definition.name) $(definition.version ?? "version " + definition.version)
//  Created $(defined(definition.author) ?? "by " + definition.author ? "") on $(date.picture())
//
//  $(defined(definition->description) ?? definition->description. ? "no description")
//  $(definition.copyright)
//

#if defined(__unix__) || defined(__linux__) || \
(defined(__APPLE__) && defined(__MACH__))
    #include <pthread.h>
#elif (defined WIN32 || defined _WIN32)
    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif
    #define NOMINMAX
    #include <windows.h>
    #include <winsock2.h>
#endif

#include <ingescape/ingescape.h>
#include <getopt.h>
.if (definition.createAgentObject)
#include "$(definition.name:c).h"
.endif

//default agent parameters to be overriden by command line parameters
.if (defined(definition.defaultPort) & string.length(definition.defaultPort))
#define PORT $(definition.defaultPort)
.else
#define PORT 5670
.endif
#define AGENT_NAME "$(definition.name)"
#define DEVICE NULL
#define IS_VERBOSE false
#define STRING_SIZE 4096
.if (defined(definition.agentFamily) & string.length(definition.agentFamily))
#define AGENT_FAMILY "$(definition.agentFamily)"
.endif

int ingescapeSentMessage(zloop_t *loop, zsock_t *reader, void *arg){
    char *message = NULL;
    zsock_recv(reader, "s", &message);
    if (streq(message, "LOOP_STOPPED")){
        igs_info("LOOP_STOPPED received from Ingescape");
        return -1;
    }else
        return 0;
}

.if (defined (definition.iopCallbackMode))
.if (!(definition.iopCallbackMode = "none"))
//inputs
.endif
.if (definition.iopCallbackMode = "grouped")
void inputsCallback(igs_io_type_t ioType, const char* name, igs_io_value_type_t valueType,
                    void* value, size_t valueSize, void* myData) {
.if ((defined (definition.createAgentObject)) & definition.createAgentObject)
    $(definition.name:c)_t *agent = ($(definition.name:c)_t *)myData;
.endif
    igs_info("%s changed", name);
    //TODO: add code depending on this agent's expected behaviour
}
.elsif (definition.iopCallbackMode = "individual")
.for definition.input
// "$(input.name)" callback
void $(nameToCName(input.name))InputCallback(igs_io_type_t ioType, const char* name, igs_io_value_type_t valueType,
                        void* value, size_t valueSize, void* myData) {
.if ((defined (definition.createAgentObject)) & definition.createAgentObject)
    $(definition.name:c)_t *agent = ($(definition.name:c)_t *)myData;
.if (input.type = "INTEGER")
    int v = *(int *)value;
    igs_info("%s changed to %d", name, v);
    $(definition.name:c)_set$(nameToCName(input.name))I(agent, v);
.elsif (input.type = "IMPULSION")
    igs_info("%s changed (impulsion)", name);
    $(definition.name:c)_set$(nameToCName(input.name))I(agent);
.elsif (input.type = "BOOL")
    bool v = *(bool *)value;
    igs_info("%s changed to %d", name, v);
    $(definition.name:c)_set$(nameToCName(input.name))I(agent, v);
.elsif (input.type = "DOUBLE")
    double v = *(double *)value;
    igs_info("%s changed to %f", name, v);
    $(definition.name:c)_set$(nameToCName(input.name))I(agent, v);
.elsif (input.type = "STRING")
    char *v = (char *)value;
    igs_info("%s changed to %s", name, v);
    $(definition.name:c)_set$(nameToCName(input.name))I(agent, v);
.elsif (input.type = "DATA")
    igs_info("%s changed (%zu bytes)", name, valueSize);
    $(definition.name:c)_set$(nameToCName(input.name))I(agent, value, valueSize);
.endif
.endif
}

.endfor
.endif
.endif
.
.if (defined (definition.iopCallbackMode))
.if (!(definition.iopCallbackMode = "none"))
//attributes
.endif
.if (definition.iopCallbackMode = "grouped")
void attributesCallback(igs_io_type_t ioType, const char* name, igs_io_value_type_t valueType,
                    void* value, size_t valueSize, void* myData) {
.if ((defined (definition.createAgentObject)) & definition.createAgentObject)
    $(definition.name:c)_t *agent = ($(definition.name:c)_t *)myData;
.endif
    igs_info("%s changed", name);
    //TODO: add code depending on this agent's expected behaviour
}
.elsif (definition.iopCallbackMode = "individual")
.for definition.parameter
// "$(parameter.name)" callback
void $(nameToCName(parameter.name))AttributeCallback(igs_io_type_t ioType, const char* name, igs_io_value_type_t valueType,
                        void* value, size_t valueSize, void* myData) {
.if ((defined (definition.createAgentObject)) & definition.createAgentObject)
    $(definition.name:c)_t *agent = ($(definition.name:c)_t *)myData;
.if (parameter.type = "INTEGER")
    int v = *(int *)value;
    igs_info("%s changed to %d", name, v);
    $(definition.name:c)_set$(nameToCName(parameter.name))A(agent, v);
.elsif (parameter.type = "IMPULSION")
    igs_info("%s changed (impulsion)", name);
    $(definition.name:c)_set$(nameToCName(parameter.name))A(agent);
.elsif (parameter.type = "BOOL")
    bool v = *(bool *)value;
    igs_info("%s changed to %d", name, v);
    $(definition.name:c)_set$(nameToCName(parameter.name))A(agent, v);
.elsif (parameter.type = "DOUBLE")
    double v = *(double *)value;
    igs_info("%s changed to %f", name, v);
    $(definition.name:c)_set$(nameToCName(parameter.name))A(agent, v);
.elsif (parameter.type = "STRING")
    char *v = (char *)value;
    igs_info("%s changed to %s", name, v);
    $(definition.name:c)_set$(nameToCName(parameter.name))A(agent, v);
.elsif (parameter.type = "DATA")
    igs_info("%s changed (%zu bytes)", name, valueSize);
    $(definition.name:c)_set$(nameToCName(parameter.name))A(agent, value, valueSize);
.endif
.endif
}

.endfor
.endif
.endif
.
.if (count(definition.service))
//services
.endif
.for service
// "$(service.name)" callback
void $(nameToCName(service.name))Callback(const char *callerAgentName, const char *callerAgentUUID,
                          const char *serviceName, igs_service_arg_t *firstArgument, size_t nbArgs,
                          const char *token, void* myData){
.if ((defined (definition.createAgentObject)) & definition.createAgentObject)
    $(definition.name:c)_t *agent = ($(definition.name:c)_t *)myData;
.endif
.argumentPrefix = "firstArgument"
.for argument
.if (argument.type = "INTEGER")
    $(typeToCType(argument.type)) $(nameToCName(argument.name)) = $(argumentPrefix)->i;
.elsif (argument.type = "BOOL")
    $(typeToCType(argument.type)) $(nameToCName(argument.name)) = $(argumentPrefix)->b;
.elsif (argument.type = "DOUBLE")
    $(typeToCType(argument.type)) $(nameToCName(argument.name)) = $(argumentPrefix)->d;
.elsif (argument.type = "STRING")
    $(typeToCType(argument.type)) $(nameToCName(argument.name)) = $(argumentPrefix)->c;
.elsif (argument.type = "DATA")
    $(typeToCType(argument.type)) $(nameToCName(argument.name)) = $(argumentPrefix)->data;
    size_t $(nameToCName(argument.name))_size = $(argumentPrefix)->size;
.endif
.argumentPrefix = argumentPrefix + "->next"
.endfor

.if (defined (definition.createAgentObject) & definition.createAgentObject)
.if (count (argument))
    $(definition.name:c)_$(nameToCName(service.name))(agent, \
.else
    $(definition.name:c)_$(nameToCName(service.name))(agent\
.endif
.for argument
$(nameToCName(argument.name))\
.if (argument.type = "DATA")
, $(nameToCName(argument.name))_size\
.endif
.if (! last ())
, \
.endif
.endfor
\);
.endif
}
.endfor

///////////////////////////////////////////////////////////////////////////////
// COMMAND LINE AND INTERPRETER OPTIONS
//
void print_usage(void){
    printf("Usage examples:\\n");
    printf("    ./$(definition.name) --verbose --device en0 --port 5670\\n");
    printf("\\nIngescape parameters:\\n");
    printf("--verbose : enable verbose mode in the application (default is disabled)\\n");
    printf("--device device_name : name of the network device to be used (useful if several devices are available)\\n");
    printf("--port port_number : port used for autodiscovery between agents (default: %d)\\n", PORT);
    printf("--name agent_name : published name of this agent (default: %s)\\n", AGENT_NAME);
    printf("--interactiveloop : enables interactive loop to pass commands in CLI (default: false)\\n");
    printf("Security:\\n");
    printf("--igsCert filePath : path to a private certificate used to connect to a secure platform\\n");
    printf("--publicCerts directoryPath : path to a directory providing public certificates usable by ingescape\\n");
.if (definition.externalDefinition)
    printf("--definition : path to an external definition file\\n");
.endif
.if (definition.externalMapping)
    printf("--mapping : path to an external mapping file\\n");
.endif
    printf("\\n");
}

//resolve paths starting with ~ to absolute paths
void resolveUserPathIn(char path[], size_t maxSize) {
    if (path && strlen(path) && path[0] == '~') {
        char *temp = strdup(path+1);
#ifdef _WIN32
        char *home = getenv("USERPROFILE");
#else
        char *home = getenv("HOME");
#endif
        if (!home)
            igs_error("could not find path for home directory");
        else{
            strncpy(path, home, maxSize);
            strncat(path, temp, maxSize);
        }
        free(temp);
    }
}

void print_cli_usage(void) {
    printf("Available commands in the terminal:\\n");
    printf("\\t/quit : quits the agent\\n");
    printf("\\t/help : displays this message\\n");
}

///////////////////////////////////////////////////////////////////////////////
// MAIN & OPTIONS & COMMAND INTERPRETER
//
//
int main(int argc, const char * argv[]) {
    int opt = 0;
    bool verbose = IS_VERBOSE;
    char *networkDevice = DEVICE;
    unsigned int port = PORT;
    char *agentName = AGENT_NAME;
    bool interactiveloop = false;
    char igsCertPath[IGS_MAX_PATH_LENGTH] = "";
    char publicCertsDir[IGS_MAX_PATH_LENGTH] = "";
.if (defined (definition.externalDefinition) & definition.externalDefinition)
    char definitionPath[IGS_MAX_PATH_LENGTH] = "";
.endif
.if (defined (definition.externalMapping) & definition.externalMapping)
    char mappingPath[IGS_MAX_PATH_LENGTH] = "";
.endif

    static struct option long_options[] = {
        {"verbose",     no_argument, 0,  'v' },
        {"device",      required_argument, 0,  'd' },
        {"port",        required_argument, 0,  'p' },
        {"name",        required_argument, 0,  'n' },
        {"interactiveloop", no_argument, 0,  'i' },
        {"help",        no_argument, 0,  'h' },
.if (defined (definition.externalDefinition) & definition.externalDefinition)
        {"definition",  required_argument, 0,  'f' },
.endif
.if (defined (definition.externalMapping) & definition.externalMapping)
        {"mapping",  required_argument, 0,  'm' },
.endif
        {"igsCert",        required_argument, 0,  'c' },
        {"publicCerts",        required_argument, 0,  's' },
        {0, 0, 0, 0}
    };

    int long_index = 0;
    while ((opt = getopt_long(argc, (char *const *)argv, "", long_options, &long_index)) != -1) {
        switch (opt) {
            case 'v':
                verbose = true;
                break;
            case 'd':
                networkDevice = optarg;
                break;
            case 'p':
                port = (unsigned int)atoi(optarg);
                break;
            case 'n':
                agentName = optarg;
                break;
            case 'i':
                interactiveloop = true;
                break;
            case 'h':
                print_usage();
                exit(IGS_SUCCESS);
            case 'c':
                strncpy(igsCertPath, optarg, IGS_MAX_PATH_LENGTH);
                break;
            case 's':
                strncpy(publicCertsDir, optarg, IGS_MAX_PATH_LENGTH);
                break;
.if (defined (definition.externalDefinition) & definition.externalDefinition)
            case 'f' :
                strncpy(definitionPath, optarg, IGS_MAX_PATH_LENGTH);
                break;
.endif
.if (defined(definition.externalMapping) & definition.externalMapping)
            case 'm' :
                strncpy(mappingPath, optarg, IGS_MAX_PATH_LENGTH);
                break;
.endif
            default:
                print_usage();
                exit(IGS_FAILURE);
        }
    }

    igs_agent_set_name(agentName);
    igs_log_set_console(verbose);
    igs_log_set_file(true, NULL);
    igs_log_set_stream(verbose);
    igs_definition_set_version("$(definition.version)");
.if (defined(definition.agentFamily) & string.length(definition.agentFamily))
    igs_agent_set_family(AGENT_FAMILY);
.endif
    igs_set_command_line_from_args(argc, argv);

    igs_debug("Ingescape version: %d (protocol v%d)", igs_version(), igs_protocol());

    //security
    resolveUserPathIn(igsCertPath, IGS_MAX_PATH_LENGTH);
    if (strlen(igsCertPath) && zfile_exists(igsCertPath))
        assert(igs_enable_security(igsCertPath, publicCertsDir) == IGS_SUCCESS);
    else if (strlen(igsCertPath)){
        igs_error("Could not find Ingescape certificate file '%s': exiting", igsCertPath);
        exit(IGS_FAILURE);
    }

    if (networkDevice == NULL){
        //we have no device to start with: try to find one
        int nbD = 0;
        int nbA = 0;
        char **devices = igs_net_devices_list(&nbD);
        char **addresses = igs_net_addresses_list(&nbA);
        assert(nbD == nbA);
        if (nbD == 1){
            //we have exactly one compliant network device available: we use it
            networkDevice = strdup(devices[0]);
            igs_info("using %s as default network device (this is the only one available)", networkDevice);
        }else if (nbD == 2 && (strcmp(addresses[0], "127.0.0.1") == 0 || strcmp(addresses[1], "127.0.0.1") == 0)){
            //we have two devices, one of which is the loopback
            //pick the device that is NOT the loopback
            if (strcmp(addresses[0], "127.0.0.1") == 0){
                networkDevice = strdup(devices[1]);
            }else{
                networkDevice = strdup(devices[0]);
            }
            igs_info("using %s as default network device (this is the only one available that is not the loopback)", networkDevice);
        }else{
            if (nbD == 0){
                igs_error("No network device found: aborting.");
            }else{
                igs_error("No network device passed as command line parameter and several are available.");
                printf("Please use one of these network devices:\\n");
                for (int i = 0; i < nbD; i++){
                    printf("\\t%s\\n", devices[i]);
                }
                printf("\\n");
                print_usage();
            }
            exit(1);
        }
        igs_free_net_devices_list(devices, nbD);
        igs_free_net_addresses_list(addresses, nbD);
    }

.if (defined (definition.externalDefinition) & definition.externalDefinition)
    //load definition
    if (strlen(definitionPath)){
        resolveUserPathIn(definitionPath, IGS_MAX_PATH_LENGTH);
        igs_definition_load_file(definitionPath);
    }

.endif
.
.if ((defined (definition.externalDefinition) & definition.externalDefinition) & (count(definition.parameter) | count(definition.input) |count(definition.output)))
    //WARNING: definition is loaded from an external file but
    //generated model also has IOAs. There might be a conflict
    //between the two.
.endif
.
.for definition.parameter
    igs_attribute_create("$(parameter.name)", $(typeToIGSType(parameter.type)), 0, 0);
.   if (defined (parameter.description) & string.length(parameter.description))
    igs_attribute_set_description("$(parameter.name)", "$(parameter.description)");
.   endif
.   if (defined (parameter.constraint) & string.length(parameter.constraint))
    igs_attribute_add_constraint("$(parameter.name)", "$(parameter.constraint)");
.   endif
.endfor
.for definition.input
    igs_input_create("$(input.name)", $(typeToIGSType(input.type)), 0, 0);
.   if (defined (input.description) & string.length(input.description))
    igs_input_set_description("$(input.name)", "$(input.description)");
.   endif
.   if (defined (input.constraint) & string.length(input.constraint))
    igs_input_add_constraint("$(input.name)", "$(input.constraint)");
.   endif
.endfor
.for definition.output
    igs_output_create("$(output.name)", $(typeToIGSType(output.type)), 0, 0);
.   if (defined (output.description) & string.length(output.description))
    igs_output_set_description("$(output.name)", "$(output.description)");
.   endif
.   if (defined (output.constraint) & string.length(output.constraint))
    igs_output_add_constraint("$(output.name)", "$(output.constraint)");
.   endif
.endfor
.
.if ((defined (definition.createAgentObject)) & definition.createAgentObject)

.endif
.

.if (defined (definition.externalMapping) & definition.externalMapping)
    //load mapping
    if (strlen(mappingPath)){
        resolveUserPathIn(mappingPath, IGS_MAX_PATH_LENGTH);
        igs_definition_load_file(mappingPath);
    }

.endif
.if ((defined (definition.createAgentObject)) & definition.createAgentObject)
    //initialize agent
    $(definition.name:c)_t *agent = $(definition.name:c)_new ();
.for definition.input
.if (definition.iopCallbackMode = "individual")
    igs_observe_input("$(input.name)", $(nameToCName(input.name))InputCallback, agent);
.elsif (definition.iopCallbackMode = "grouped")
    igs_observe_input("$(input.name)", inputsCallback, agent);
.endif
.endfor
.for definition.parameter
.if (definition.iopCallbackMode = "individual")
    igs_observe_attribute("$(parameter.name)", $(nameToCName(parameter.name))AttributeCallback, agent);
.elsif (definition.iopCallbackMode = "grouped")
    igs_observe_attribute("$(parameter.name)", attributesCallback, agent);
.endif
.endfor
.for service
    igs_service_init("$(service.name)", $(nameToCName(service.name))Callback, agent);
.for argument
    igs_service_arg_add("$(service.name)", "$(argument.name)", $(typeToIGSType(argument.type)));
.endfor
.for service.reply
    igs_service_reply_add("$(service.name)", "$(reply.name)");
.   for reply.argument
    igs_service_reply_arg_add("$(service.name)", "$(reply.name)", "$(argument.name)", $(typeToIGSType(argument.type)));
.   endfor
.endfor
.endfor
.else
.for definition.input
.if (definition.iopCallbackMode = "individual")
    igs_observe_input("$(input.name)", $(nameToCName(input.name))InputCallback, NULL);
.elsif (definition.iopCallbackMode = "grouped")
    igs_observe_input("$(input.name)", inputsCallback, NULL);
.endif
.endfor
.for definition.parameter
.if (definition.iopCallbackMode = "individual")
    igs_observe_attribute("$(parameter.name)", $(nameToCName(parameter.name))AttributeCallback, NULL);
.elsif (definition.iopCallbackMode = "grouped")
    igs_observe_attribute("$(parameter.name)", attributesCallback, NULL);
.endif
.endfor
.for service
    igs_service_init("$(service.name)", $(nameToCName(service.name))Callback, NULL);
.for argument
    igs_service_arg_add("$(service.name)", "$(argument.name)", $(typeToIGSType(argument.type)));
.endfor
.endfor
.endif

    //actually start ingescape
    igs_start_with_device(networkDevice, port);

    //mainloop management (two modes)
    if (!interactiveloop) {
        //Run the main loop (non-interactive mode):
        //we rely on CZMQ which is an ingescape dependency
        //and is thus always available.
        zloop_t *loop = zloop_new();
        zsock_t *pipe = igs_pipe_to_ingescape();
        if (pipe)
            zloop_reader(loop, pipe, ingescapeSentMessage, NULL);
        zloop_start(loop);
        zloop_destroy(&loop);
    }else{
        char message[IGS_MAX_LOG_LENGTH];
        char command[IGS_MAX_LOG_LENGTH];
        char param1[IGS_MAX_LOG_LENGTH];
        char param2[IGS_MAX_LOG_LENGTH];
        int usedChar = 0;
        print_cli_usage();
        while (igs_is_started()) {
            if (!fgets(message, IGS_MAX_LOG_LENGTH, stdin))
                break;
            if ((message[0] == '/') && (strlen(message) > 2)) {
                int matches = sscanf(message + 1, "%s %s%n%s", command, param1, &usedChar, param2);
                if (matches > 2) {
                    // copy the remaining of the message in param 2
                    strncpy(param2, message + usedChar + 2, IGS_MAX_LOG_LENGTH);
                    // remove '\\n' at the end
                    param2[strnlen(param2, IGS_MAX_LOG_LENGTH) - 1] = '\\0';
                }
                // Process command
                if (matches == -1) {
                    //printf("Error: could not interpret message %s\\n", message + 1);
                }else if (matches == 1) {
                    if (strncmp(command, "quit", IGS_MAX_LOG_LENGTH) == 0){
                        break;
                    }else if(strncmp(command, "help", IGS_MAX_LOG_LENGTH) == 0){
                        print_cli_usage();
                    }else {
                        printf("Received command: %s\\n", command);
                    }
                }else if (matches == 2) {
                    printf("Received command: %s + %s\\n", command, param1);
                }else if (matches == 3) {
                    printf("Received command: %s + %s + %s\\n", command, param1, param2);
                }else{
                    printf("Error: message returned %d matches (%s)\\n", matches, message);
                }
            }
        }
    }

.if ((defined (definition.createAgentObject)) & definition.createAgentObject)
    $(definition.name:c)_destroy (&agent);
.endif
    igs_stop();

    return 0;
}
.
.####################################################################################
.if ((defined (definition.createAgentObject)) & definition.createAgentObject)
.echo "Generating src/$(definition.name:c).h ..."
.output "src/$(definition.name:c).h"
//
//  $(definition.name:c)
//  Created $(defined(definition.author) ?? "by " + definition.author ? "") on $(date.picture())
//
//  $(defined(definition->description) ?? definition->description. ? "no description")
//  $(definition.copyright)
//
#ifndef $(definition.name :c)_h
#define $(definition.name :c)_h

#include <ingescape/ingescape.h>

typedef struct _$(definition.name:c)_t $(definition.name:c)_t;
$(definition.name:c)_t* $(definition.name:c)_new (void);
void $(definition.name:c)_destroy ($(definition.name:c)_t **agent);

.if (definition.iopCallbackMode = "individual" & count(input))
//inputs
.for definition.input
// "$(input.name)"
.if (input.type = "IMPULSION")
void $(definition.name:c)_set$(nameToCName(input.name))I($(definition.name:c)_t *agent);
.elsif (input.type = "DATA")
void $(definition.name:c)_set$(nameToCName(input.name))I($(definition.name:c)_t *agent, void *value, size_t size);
$(typeToCType(input.type)) $(definition.name:c)_get$(nameToCName(input.name))I($(definition.name:c)_t *agent, size_t *size);
.else
void $(definition.name:c)_set$(nameToCName(input.name))I($(definition.name:c)_t *agent, $(typeToCType (input.type)) value);
$(typeToCType(input.type)) $(definition.name:c)_get$(nameToCName(input.name))I($(definition.name:c)_t *agent);
.endif
.endfor

.endif
.if (definition.iopCallbackMode = "individual" & count(output))
//outputs
.for definition.output
// "$(output.name)"
.if (output.type = "IMPULSION")
void $(definition.name:c)_set$(nameToCName(output.name))O($(definition.name:c)_t *agent);
.elsif (output.type = "DATA")
void $(definition.name:c)_set$(nameToCName(output.name))O($(definition.name:c)_t *agent, void *value, size_t size);
$(typeToCType(output.type)) $(definition.name:c)_get$(nameToCName(output.name))O($(definition.name:c)_t *agent, size_t *size);
.else
void $(definition.name:c)_set$(nameToCName(output.name))O($(definition.name:c)_t *agent, $(typeToCType (output.type)) value);
$(typeToCType(output.type)) $(definition.name:c)_get$(nameToCName(output.name))O($(definition.name:c)_t *agent);
.endif
.endfor

.endif
.if (definition.iopCallbackMode = "individual" & count(parameter))
//attributes
.for definition.parameter
// "$(parameter.name)"
.if (parameter.type = "IMPULSION")
void $(definition.name:c)_set$(nameToCName(parameter.name))A($(definition.name:c)_t *agent);
.elsif (parameter.type = "DATA")
void $(definition.name:c)_set$(nameToCName(parameter.name))A($(definition.name:c)_t *agent, void *value, size_t size);
$(typeToCType(parameter.type)) $(definition.name:c)_get$(nameToCName(parameter.name))A($(definition.name:c)_t *agent, size_t *size);
.else
void $(definition.name:c)_set$(nameToCName(parameter.name))A($(definition.name:c)_t *agent, $(typeToCType (parameter.type)) value);
$(typeToCType(parameter.type)) $(definition.name:c)_get$(nameToCName(parameter.name))A($(definition.name:c)_t *agent);
.endif
.endfor

.endif
.
.if (count (service))
//services
.endif
.for service
// "$(service.name)"
.if (count (argument))
void $(definition.name:c)_$(nameToCName(service.name))($(definition.name:c)_t *agent, \
.else
void $(definition.name:c)_$(nameToCName(service.name))($(definition.name:c)_t *agent);
.endif
.for argument
$(typeToCType(argument.type)) $(nameToCName(argument.name))\
.if (argument.type = "DATA")
, size_t $(nameToCName(argument.name))_size\
.endif
.if (! last ())
, \
.endif
.endfor
\);
.endfor

#endif /* $(definition.name :c)_h */
.
.####################################################################################
.echo "Generating src/$(definition.name:c).c ..."
.output "src/$(definition.name:c).c"
//
//  $(definition.name)
//
//  Created by $(definition.author) on $(date.picture()).
//  $(definition.copyright)
//

#include "$(definition.name:c).h"
#include <string.h>

struct _$(definition.name:c)_t {
.iopNb = 0
.if (count(input))
    //inputs
.endif
.for input
.if (input.type = "DATA")
    // "$(input.name)"
    $(typeToCType(input.type)) $(nameToCName(input.name))I;
    size_t $(nameToCName(input.name))I_size;
.iopNb = iopNb + 1
.elsif (input.type = "IMPULSION")
.else
    // "$(input.name)"
    $(typeToCType(input.type)) $(nameToCName(input.name))I;
.iopNb = iopNb + 1
.endif
.endfor
.if (count(output))

    //outputs
.endif
.for output
.if (output.type = "DATA")
    // "$(output.name)"
    $(typeToCType(output.type)) $(nameToCName(output.name))O;
    size_t $(nameToCName(output.name))O_size;
.iopNb = iopNb + 1
.elsif (output.type = "IMPULSION")
.else
    // "$(output.name)"
    $(typeToCType(output.type)) $(nameToCName(output.name))O;
.iopNb = iopNb + 1
.endif
.endfor
.if (count(parameter))

    //attributes
.endif
.for parameter
.if (parameter.type = "DATA")
    // "$(parameter.name)"
    $(typeToCType(parameter.type)) $(nameToCName(parameter.name))A;
    size_t $(nameToCName(parameter.name))A_size;
.iopNb = iopNb + 1
.elsif (parameter.type = "IMPULSION")
.else
    // "$(parameter.name)"
    $(typeToCType(parameter.type)) $(nameToCName(parameter.name))A;
.iopNb = iopNb + 1
.endif
.endfor
.if (iopNb = 0)
    void *empty;
.endif
};


$(definition.name:c)_t *$(definition.name:c)_new (void){
    $(definition.name:c)_t *agent = ($(definition.name:c)_t *) calloc(1, sizeof($(definition.name:c)_t));

    //add code here if needed

    return agent;
}

void $(definition.name:c)_destroy ($(definition.name:c)_t **agent){
    if (agent != NULL && *agent != NULL){
.for input
.if ((input.type = "STRING") | (input.type = "DATA"))
        if ((*agent)->$(nameToCName(input.name))I != NULL){
            free((*agent)->$(nameToCName(input.name))I);
            (*agent)->$(nameToCName(input.name))I = NULL;
        }
.endif
.endfor
.for output
.if ((output.type = "STRING") | (output.type = "DATA"))
        if ((*agent)->$(nameToCName(output.name))O != NULL){
            free((*agent)->$(nameToCName(output.name))O);
            (*agent)->$(nameToCName(output.name))O = NULL;
        }
.endif
.endfor
.for parameter
.if ((parameter.type = "STRING") | (parameter.type = "DATA"))
        if ((*agent)->$(nameToCName(parameter.name))A != NULL){
            free((*agent)->$(nameToCName(parameter.name))A);
            (*agent)->$(nameToCName(parameter.name))A = NULL;
        }
.endif
.endfor
        free(*agent);
        *agent = NULL;
    }
}
.if (definition.iopCallbackMode = "individual" & count(input))

/////////////////////////////////////////////////////////////////////
//inputs
.for definition.input
// $(input.name)
.if (input.type = "IMPULSION")
void $(definition.name:c)_set$(nameToCName(input.name))I($(definition.name:c)_t *agent){
    assert(agent);

    //add code here if needed

}

.elsif (input.type = "DATA")
void $(definition.name:c)_set$(nameToCName(input.name))I($(definition.name:c)_t *agent, void *value, size_t size){
    assert(agent);
    if (agent->$(nameToCName(input.name))I != NULL)
        free(agent->$(nameToCName(input.name))I);
    void *data = calloc(1, size);
    agent->$(nameToCName(input.name))I = (value == NULL)? NULL : memcpy(data, value, size);
    agent->$(nameToCName(input.name))I_size = size;

    //add code here if needed

}
$(typeToCType(input.type)) $(definition.name:c)_get$(nameToCName(input.name))I($(definition.name:c)_t *agent, size_t *size){
    assert(agent);
    //FIXME: decide if we do a copy here or not
    *size = agent->$(nameToCName(input.name))I_size;
    return agent->$(nameToCName(input.name))I;
}

.elsif (input.type = "STRING")
void $(definition.name:c)_set$(nameToCName(input.name))I($(definition.name:c)_t *agent, $(typeToCType (input.type)) value){
    assert(agent);
    if (agent->$(nameToCName(input.name))I != NULL)
        free(agent->$(nameToCName(input.name))I);
    char *text = (char *)calloc(1, strlen((char *)value) + 1);
    agent->$(nameToCName(input.name))I = (value == NULL)? NULL : memcpy(text, value, strlen((char *)value) + 1);

    //add code here if needed

}
$(typeToCType(input.type)) $(definition.name:c)_get$(nameToCName(input.name))I($(definition.name:c)_t *agent){
    assert(agent);
    //FIXME: decide if we do a copy here or not
    return agent->$(nameToCName(input.name))I;
}

.else
void $(definition.name:c)_set$(nameToCName(input.name))I($(definition.name:c)_t *agent, $(typeToCType (input.type)) value){
    assert(agent);
    agent->$(nameToCName(input.name))I = value;

    //add code here if needed

}
$(typeToCType(input.type)) $(definition.name:c)_get$(nameToCName(input.name))I($(definition.name:c)_t *agent){
    assert(agent);
    return agent->$(nameToCName(input.name))I;
}

.endif
.endfor
.endif
.if (definition.iopCallbackMode = "individual" & count(output))
/////////////////////////////////////////////////////////////////////
//outputs
.for definition.output
// $(output.name)
.if (output.type = "IMPULSION")
void $(definition.name:c)_set$(nameToCName(output.name))O($(definition.name:c)_t *agent){
    assert(agent);

    //add code here if needed

    igs_output_set_impulsion("$(output.name)");
}

.elsif (output.type = "DATA")
void $(definition.name:c)_set$(nameToCName(output.name))O($(definition.name:c)_t *agent, void *value, size_t size){
    assert(agent);
    if (agent->$(nameToCName(output.name))O != NULL)
        free(agent->$(nameToCName(output.name))O);
    void *data = calloc(1, size);
    agent->$(nameToCName(output.name))O = (value == NULL)? NULL : memcpy(data, value, size);
    agent->$(nameToCName(output.name))O_size = size;

    //add code here if needed

    igs_output_set_data("$(output.name)", agent->$(nameToCName(output.name))O, size);
}
$(typeToCType(output.type)) $(definition.name:c)_get$(nameToCName(output.name))O($(definition.name:c)_t *agent, size_t *size){
    assert(agent);
    //FIXME: decide if we do a copy here or not
    *size = agent->$(nameToCName(output.name))O_size;
    return agent->$(nameToCName(output.name))O;
}

.elsif (output.type = "STRING")
void $(definition.name:c)_set$(nameToCName(output.name))O($(definition.name:c)_t *agent, $(typeToCType (output.type)) value){
    assert(agent);
    if (agent->$(nameToCName(output.name))O != NULL)
        free(agent->$(nameToCName(output.name))O);
    char *text = (char *)calloc(1, strlen((char *)value) + 1);
    agent->$(nameToCName(output.name))O = (value == NULL)? NULL : memcpy(text, value, strlen((char *)value) + 1);

    //add code here if needed

    igs_output_set_string("$(output.name)", agent->$(nameToCName(output.name))O);
}
$(typeToCType(output.type)) $(definition.name:c)_get$(nameToCName(output.name))O($(definition.name:c)_t *agent){
    assert(agent);
    //FIXME: decide if we do a copy here or not
    return agent->$(nameToCName(output.name))O;
}

.else
void $(definition.name:c)_set$(nameToCName(output.name))O($(definition.name:c)_t *agent, $(typeToCType (output.type)) value){
    assert(agent);
    agent->$(nameToCName(output.name))O = value;

    //add code here if needed

.if (output.type = "INTEGER")
    igs_output_set_int("$(output.name)", agent->$(nameToCName(output.name))O);
.elsif (output.type = "BOOL")
    igs_output_set_bool("$(output.name)", agent->$(nameToCName(output.name))O);
.elsif (output.type = "DOUBLE")
    igs_output_set_double("$(output.name)", agent->$(nameToCName(output.name))O);
.endif
}
$(typeToCType(output.type)) $(definition.name:c)_get$(nameToCName(output.name))O($(definition.name:c)_t *agent){
    assert(agent);
    return agent->$(nameToCName(output.name))O;
}

.endif
.endfor
.endif
.if (definition.iopCallbackMode = "individual" & count(parameter))
/////////////////////////////////////////////////////////////////////
//attributes
.for definition.parameter
// $(parameter.name)
.if (parameter.type = "IMPULSION")
void $(definition.name:c)_set$(nameToCName(parameter.name))A($(definition.name:c)_t *agent){
    if (agent == NULL){
        igs_error("agent cannot be NULL");
        return;
    }

    //add code here if needed

}

.elsif (parameter.type = "DATA")
void $(definition.name:c)_set$(nameToCName(parameter.name))A($(definition.name:c)_t *agent, void *value, size_t size){
    assert(agent);
    if (agent->$(nameToCName(parameter.name))A != NULL)
        free(agent->$(nameToCName(parameter.name))A);
    void *data = calloc(1, size);
    agent->$(nameToCName(parameter.name))A = (value == NULL)? NULL : memcpy(data, value, size);
    agent->$(nameToCName(parameter.name))A_size = size;

    //add code here if needed
}
$(typeToCType(parameter.type)) $(definition.name:c)_get$(nameToCName(parameter.name))A($(definition.name:c)_t *agent, size_t *size){
    assert(agent);
    //FIXME: decide if we do a copy here or not
    *size = agent->$(nameToCName(parameter.name))A_size;
    return agent->$(nameToCName(parameter.name))A;
}

.elsif (parameter.type = "STRING")
void $(definition.name:c)_set$(nameToCName(parameter.name))A($(definition.name:c)_t *agent, $(typeToCType (parameter.type)) value){
    assert(agent);
    if (agent->$(nameToCName(parameter.name))A != NULL)
        free(agent->$(nameToCName(parameter.name))A);
    char *text = (char *)calloc(1, strlen((char *)value) + 1);
    agent->$(nameToCName(parameter.name))A = (value == NULL)? NULL : memcpy(text, value, strlen((char *)value) + 1);

    //add code here if needed

}
$(typeToCType(parameter.type)) $(definition.name:c)_get$(nameToCName(parameter.name))A($(definition.name:c)_t *agent){
    assert(agent);
    //FIXME: decide if we do a copy here or not
    return agent->$(nameToCName(parameter.name))A;
}

.else
void $(definition.name:c)_set$(nameToCName(parameter.name))A($(definition.name:c)_t *agent, $(typeToCType (parameter.type)) value){
    assert(agent);
    agent->$(nameToCName(parameter.name))A = value;

    //add code here if needed

}
$(typeToCType(parameter.type)) $(definition.name:c)_get$(nameToCName(parameter.name))A($(definition.name:c)_t *agent){
    assert(agent);
    return agent->$(nameToCName(parameter.name))A;
}

.endif
.endfor

.endif
.if (count (service))
/////////////////////////////////////////////////////////////////////
//services
.endif
.for service
.if (count (argument))
void $(definition.name:c)_$(nameToCName(service.name))($(definition.name:c)_t *agent, \
.else
void $(definition.name:c)_$(nameToCName(service.name))($(definition.name:c)_t *agent\
.endif
.for argument
$(typeToCType(argument.type)) $(nameToCName(argument.name))\
.if (argument.type = "DATA")
, size_t $(nameToCName(argument.name))_size\
.endif
.if (! last ())
, \
.endif
.endfor
\){
    assert(agent);

    //add code here if needed

}

.endfor
.
.endif
.
.####################################################################################
.echo "Generating CMakeLists.txt ..."
.output "CMakeLists.txt"
cmake_minimum_required(VERSION 3.5)

# Project name can only contains upper and lower case letters, numbers,
# the underscore character (_), dot(.), plus(+) and minus(-).
project($(definition.name:c))

.if (defined (definition.version) & string.length(definition.version))
set (VERSION "1.0.0")
.endif

set(CMAKE_MODULES_DIR "${CMAKE_CURRENT_SOURCE_DIR}/builds/cmake")
list(APPEND CMAKE_MODULE_PATH ${CMAKE_MODULES_DIR})
include(IdentifyOS)

# agent and external dependencies (if any)
add_executable(${PROJECT_NAME}
.if (defined (definition.createAgentObject) & definition.createAgentObject)
    src/$(definition.name:c).c
    src/$(definition.name:c).h
.endif
    src/main.c)

# set executable name
set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME "$(definition.name)")

# Override default release flags to not define NDEBUG, which CMake sets by default for Release builds
# NB: The NDEBUG flag compile out all assert() calls, skipping whatever was done in the assert call (function call, computation, etc.)
# It changes the compiled code from the source code and we don't want that.
if (NOT CMAKE_BUILD_TYPE STREQUAL "Debug")
   # Enable assertions in release mode
   message(STATUS "Enable C asserts in release mode (instead of noop)")
   if (MSVC)
       string(REPLACE "/D NDEBUG" "" CMAKE_CXX_FLAGS_RELEASE ${CMAKE_CXX_FLAGS_RELEASE})
       string(REPLACE "/D NDEBUG" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO ${CMAKE_CXX_FLAGS_RELWITHDEBINFO})
       string(REPLACE "/D NDEBUG" "" CMAKE_CXX_FLAGS_MINSIZEREL ${CMAKE_CXX_FLAGS_MINSIZEREL})

       string(REPLACE "/DNDEBUG" "" CMAKE_CXX_FLAGS_RELEASE ${CMAKE_CXX_FLAGS_RELEASE})
       string(REPLACE "/DNDEBUG" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO ${CMAKE_CXX_FLAGS_RELWITHDEBINFO})
       string(REPLACE "/DNDEBUG" "" CMAKE_CXX_FLAGS_MINSIZEREL ${CMAKE_CXX_FLAGS_MINSIZEREL})

       string(REPLACE "/D NDEBUG" "" CMAKE_C_FLAGS_RELEASE ${CMAKE_C_FLAGS_RELEASE})
       string(REPLACE "/D NDEBUG" "" CMAKE_C_FLAGS_RELWITHDEBINFO ${CMAKE_C_FLAGS_RELWITHDEBINFO})
       string(REPLACE "/D NDEBUG" "" CMAKE_C_FLAGS_MINSIZEREL ${CMAKE_C_FLAGS_MINSIZEREL})

       string(REPLACE "/DNDEBUG" "" CMAKE_C_FLAGS_RELEASE ${CMAKE_C_FLAGS_RELEASE})
       string(REPLACE "/DNDEBUG" "" CMAKE_C_FLAGS_RELWITHDEBINFO ${CMAKE_C_FLAGS_RELWITHDEBINFO})
       string(REPLACE "/DNDEBUG" "" CMAKE_C_FLAGS_MINSIZEREL ${CMAKE_C_FLAGS_MINSIZEREL})
   else()
       string(REPLACE "-DNDEBUG" "" CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}")
       string(REPLACE "-DNDEBUG" "" CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "-DNDEBUG" "" CMAKE_CXX_FLAGS_MINSIZEREL "${CMAKE_CXX_FLAGS_MINSIZEREL}")

       string(REPLACE "-DNDEBUG" "" CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE}")
       string(REPLACE "-DNDEBUG" "" CMAKE_C_FLAGS_RELWITHDEBINFO "${CMAKE_C_FLAGS_RELWITHDEBINFO}")
       string(REPLACE "-DNDEBUG" "" CMAKE_C_FLAGS_MINSIZEREL "${CMAKE_C_FLAGS_MINSIZEREL}")
   endif()
endif()

option(WITH_ASAN "Activate Clang Address Sanitizer" OFF)
if (WITH_ASAN)
  message (STATUS "Clang Address Sanitizer activated by passing -DWITH_ASAN=ON")
  target_compile_options(${PROJECT_NAME} PRIVATE -fsanitize=address)
  target_link_options(${PROJECT_NAME} PRIVATE -fsanitize=address)
endif(WITH_ASAN)

if(UNIX AND NOT APPLE)
    #FIXME Is the condition necessary even when using C_STANDARD property?
    set_target_properties(${PROJECT_NAME}
      PROPERTIES
        C_STANDARD 99
    )
endif()

target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src) # local headers

if (WIN32)
    target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/packaging/windows)
endif (WIN32)

find_package (sodium)
find_package (ZeroMQ 4.3.3 REQUIRED)
if (ZeroMQ_FOUND)
    target_link_libraries (${PROJECT_NAME} PRIVATE libzmq)
else (ZeroMQ_FOUND)
    message(FATAL_ERROR "ZeroMQ - Dependency not found")
endif (ZeroMQ_FOUND)

find_package (czmq 4.2.1 REQUIRED)
if (czmq_FOUND)
    target_link_libraries (${PROJECT_NAME} PRIVATE czmq)
else (czmq_FOUND)
    message(FATAL_ERROR "czmq - Dependency not found")
endif (czmq_FOUND)

find_package (zyre 2.0.1 REQUIRED)
if (zyre_FOUND)
  target_link_libraries (${PROJECT_NAME} PRIVATE zyre)
else (zyre_FOUND)
  message(FATAL_ERROR "zyre - Dependency not found")
endif (zyre_FOUND)

find_package (ingescape 2.5 REQUIRED)
if (ingescape_FOUND)
    target_link_libraries (${PROJECT_NAME} PRIVATE ingescape)
else (ingescape_FOUND)
    message(FATAL_ERROR "ingescape - Dependency not found")
endif (ingescape_FOUND)

set_property( DIRECTORY PROPERTY VS_STARTUP_PROJECT "${PROJECT_NAME}" )

install (TARGETS ${PROJECT_NAME} RUNTIME DESTINATION bin COMPONENT agent)

########################################################################
# installer
########################################################################
# Package installer for release build only
if (CMAKE_BUILD_TYPE STREQUAL "Release")
  set(CPACK_PACKAGE_NAME "${PROJECT_NAME}")
  set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "${OUTPUT_NAME} ingescape agent")
  set(CPACK_PACKAGE_DESCRIPTION "${OUTPUT_NAME} ingescape agent")
  set(CPACK_PACKAGE_HOMEPAGE_URL "https://ingescape.com")
  set(CPACK_PACKAGE_VENDOR "$(definition.author)")
  set(CPACK_PACKAGE_CONTACT "")
  set(CPACK_PACKAGE_VERSION ${VERSION})
  set(CPACK_STRIP_FILES TRUE)

  set(CPACK_SOURCE_IGNORE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/.git/;${CMAKE_CURRENT_SOURCE_DIR}/build/")

  if (WIN32)
    # Installers for 32- vs. 64-bit CMake:
    #  - Root install directory (displayed to end user at installer-run time)
    #  - "NSIS package/display name" (text used in the installer GUI)
    #  - Registry key used to store info about the installation
    if(CMAKE_CL_64)
      set(CPACK_NSIS_INSTALL_ROOT "$PROGRAMFILES64")
      set(CPACK_NSIS_PACKAGE_NAME "${CPACK_PACKAGE_NAME} ${CPACK_PACKAGE_VERSION} (Win64)")
      set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY "${CPACK_PACKAGE_NAME} (Win64)")
    else()
      set(CPACK_NSIS_INSTALL_ROOT "$PROGRAMFILES")
      set(CPACK_NSIS_PACKAGE_NAME "${CPACK_PACKAGE_NAME} ${CPACK_PACKAGE_VERSION}")
      set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY "${CPACK_PACKAGE_NAME} (Win32)")
    endif()

    # On windows put all agents in ingescape directory
    set(CPACK_PACKAGE_INSTALL_DIRECTORY "ingescape")

    # NSIS configuration for Windows
    set(CPACK_NSIS_DISPLAY_NAME "First full agent")
    set(CPACK_NSIS_PACKAGE_NAME ${PROJECT_NAME})
    set(CPACK_NSIS_HELP_LINK "https://ingescape.com")
    set(CPACK_NSIS_CONTACT "contact@ingescape.com")

    set(CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL ON)
    set(CPACK_NSIS_MODIFY_PATH OFF)
    set(CPACK_NSIS_URL_INFO_ABOUT ${CMAKE_PROJECT_HOMEPAGE_URL})
    set(CPACK_MONOLITHIC_INSTALL ON)
    set(CPACK_GENERATOR "NSIS;ZIP")

  elseif ( ${CMAKE_SYSTEM_NAME} MATCHES "Darwin" )
    # Without component productbuild will not package any files
    set (CPACK_COMPONENTS_ALL agent)
    set(CPACK_PACKAGING_INSTALL_PREFIX "/usr/local")
    set(CPACK_PACKAGING_INSTALL_PREFIX "/usr/local")
    set(CPACK_SYSTEM_NAME "macos")
    set(CPACK_GENERATOR "productbuild;ZIP")

    configure_file("${CMAKE_CURRENT_SOURCE_DIR}/LICENSE" "${CMAKE_BINARY_DIR}/LICENSE.txt" COPYONLY)
    set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_BINARY_DIR}/LICENSE.txt")

  else ()
    set(CPACK_MONOLITHIC_INSTALL ON)
    install(FILES "${CMAKE_CURRENT_SOURCE_DIR}/packaging/unix/install_script.sh"
            DESTINATION "."
            PERMISSIONS OWNER_READ OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE
            COMPONENT agent)
    set(CPACK_GENERATOR "TGZ")
  endif ()

  include (CPack)
endif()

# ##############################################################################
# summary
# ##############################################################################
message("")
message(STATUS "******************* Configuration Summary *******************")
message(STATUS "General:")
message(STATUS "  Version           :   ${VERSION}")
message(STATUS "  System            :   ${CMAKE_SYSTEM_NAME}")
message(STATUS "  C compiler        :   ${CMAKE_C_COMPILER}")
message(
  STATUS "  Debug C flags     :   ${CMAKE_C_FLAGS_DEBUG} ${CMAKE_C_FLAGS}")
message(
  STATUS "  Release C flags   :   ${CMAKE_C_FLAGS_RELEASE} ${CMAKE_C_FLAGS}")
message(STATUS "  Build type        :   ${CMAKE_BUILD_TYPE}")
message(STATUS "")
message(STATUS "Dependencies:")
include(FeatureSummary)
feature_summary(WHAT ALL FATAL_ON_MISSING_REQUIRED_PACKAGES)
message(STATUS "")
message(STATUS "Install:")
message(STATUS "  Install prefix    :   ${CMAKE_INSTALL_PREFIX}")
message(STATUS "")
if(NOT MSVC)
  message(
    STATUS "*************************************************************")
  message(STATUS "Configuration complete! Now procced with:")
  message(STATUS "  'make'                compile the project")
  message(
    STATUS
      "  'make install'        install the project to ${CMAKE_INSTALL_PREFIX}")
  message(
    STATUS
      "  'make uninstall'      uninstall the project from ${CMAKE_INSTALL_PREFIX}"
    )
  if(CMAKE_BUILD_TYPE STREQUAL "Release")
    message(STATUS "  'make package'        Create library installer")
  endif()
endif()
message(STATUS "")




.####################################################################################
.echo "Generating other static files ..."
.output "LICENSE"
Add your license here
.
.output "README.md"
Here are some useful cmake commands for the compilation and to generate projects for some IDEs.

## Compile, run and package
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug
make -j8 -C build
```

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
make -j8 -C build
make -j8 -C build package
```

## Generate Xcode project
```bash
cmake -S . -B builds/xcode -DCMAKE_BUILD_TYPE=Debug -G "Xcode"
```

## Generate Visual Studio project
```bash
cmake -S . -B builds/visualstudio -DCMAKE_BUILD_TYPE=Debug -G "Visual Studio 10"
```
.
.output "packaging/windows/getopt.h"
#ifndef __GETOPT_H__
/**
 * DISCLAIMER
 * This file is part of the mingw-w64 runtime package.
 *
 * The mingw-w64 runtime package and its code is distributed in the hope that it
 * will be useful but WITHOUT ANY WARRANTY.  ALL WARRANTIES, EXPRESSED OR
 * IMPLIED ARE HEREBY DISCLAIMED.  This includes but is not limited to
 * warranties of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */
 /*
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */
/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Dieter Baron and Thomas Klausner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#pragma warning(disable:4996)

#define __GETOPT_H__

/* All the headers include this file. */
#include <crtdefs.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

#define    REPLACE_GETOPT        /* use this getopt as the system getopt(3) */

#ifdef REPLACE_GETOPT
int    opterr = 1;        /* if error message should be printed */
int    optind = 1;        /* index into parent argv vector */
int    optopt = '?';        /* character checked for validity */
#undef    optreset        /* see getopt.h */
#define    optreset        __mingw_optreset
int    optreset;        /* reset getopt */
char    *optarg;        /* argument associated with option */
#endif

//extern int optind;        /* index of first non-option in argv      */
//extern int optopt;        /* single option character, as parsed     */
//extern int opterr;        /* flag to enable built-in diagnostics... */
//                /* (user may set to zero, to suppress)    */
//
//extern char *optarg;        /* pointer to argument of current option  */

#define PRINT_ERROR    ((opterr) && (*options != ':'))

#define FLAG_PERMUTE    0x01    /* permute non-options to the end of argv */
#define FLAG_ALLARGS    0x02    /* treat non-options as args to option "-1" */
#define FLAG_LONGONLY    0x04    /* operate as getopt_long_only */

/* return values */
#define    BADCH        (int)'?'
#define    BADARG        ((*options == ':') ? (int)':' : (int)'?')
#define    INORDER     (int)1

#ifndef __CYGWIN__
#define __progname __argv[0]
#else
extern char __declspec(dllimport) *__progname;
#endif

#ifdef __CYGWIN__
static char EMSG[] = "";
#else
#define    EMSG        ""
#endif

struct option        /* specification for a long form option...    */
{
  const char *name;        /* option name, without leading hyphens */
  int         has_arg;        /* does it take an argument?        */
  int        *flag;        /* where to save its status, or NULL    */
  int         val;        /* its associated status value        */
};

static int getopt_internal(int, char * const *, const char *,
                           const struct option *, int *, int);
static int parse_long_options(char * const *, const char *,
                              const struct option *, int *, int);
static int gcd(int, int);
static void permute_args(int, int, int, char * const *);

static char *place = EMSG; /* option letter processing */

/* XXX: set optreset to 1 rather than these two */
static int nonopt_start = -1; /* first non option argument (for permute) */
static int nonopt_end = -1;   /* first option after non options (for permute) */

/* Error messages */
static const char recargchar[] = "option requires an argument -- %c";
static const char recargstring[] = "option requires an argument -- %s";
static const char ambig[] = "ambiguous option -- %.*s";
static const char noarg[] = "option doesn't take an argument -- %.*s";
static const char illoptchar[] = "unknown option -- %c";
static const char illoptstring[] = "unknown option -- %s";

static void
_vwarnx(const char *fmt,va_list ap)
{
  (void)fprintf(stderr,"%s: ",__progname);
  if (fmt != NULL)
    (void)vfprintf(stderr,fmt,ap);
  (void)fprintf(stderr,"\\n");
}

static void
warnx(const char *fmt,...)
{
  va_list ap;
  va_start(ap,fmt);
  _vwarnx(fmt,ap);
  va_end(ap);
}

/*
 * Compute the greatest common divisor of a and b.
 */
static int
gcd(int a, int b)
{
        int c;

        c = a % b;
        while (c != 0) {
                a = b;
                b = c;
                c = a % b;
        }

        return (b);
}

/*
 * Exchange the block from nonopt_start to nonopt_end with the block
 * from nonopt_end to opt_end (keeping the same order of arguments
 * in each block).
 */
static void
permute_args(int panonopt_start, int panonopt_end, int opt_end,
        char * const *nargv)
{
        int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
        char *swap;

        /*
         * compute lengths of blocks and number and size of cycles
         */
        nnonopts = panonopt_end - panonopt_start;
        nopts = opt_end - panonopt_end;
        ncycle = gcd(nnonopts, nopts);
        cyclelen = (opt_end - panonopt_start) / ncycle;

        for (i = 0; i < ncycle; i++) {
                cstart = panonopt_end+i;
                pos = cstart;
                for (j = 0; j < cyclelen; j++) {
                        if (pos >= panonopt_end)
                                pos -= nnonopts;
                        else
                                pos += nopts;
                        swap = nargv[pos];
                        /* LINTED const cast */
                        ((char **) nargv)[pos] = nargv[cstart];
                        /* LINTED const cast */
                        ((char **)nargv)[cstart] = swap;
                }
        }
}

#ifdef REPLACE_GETOPT
/*
 * getopt --
 *    Parse argc/argv argument vector.
 *
 * [eventually this will replace the BSD getopt]
 */
int
getopt(int nargc, char * const *nargv, const char *options)
{

        /*
         * We don't pass FLAG_PERMUTE to getopt_internal() since
         * the BSD getopt(3) (unlike GNU) has never done this.
         *
         * Furthermore, since many privileged programs call getopt()
         * before dropping privileges it makes sense to keep things
         * as simple (and bug-free) as possible.
         */
        return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
}
#endif /* REPLACE_GETOPT */

//extern int getopt(int nargc, char * const *nargv, const char *options);

#ifdef _BSD_SOURCE
/*
 * BSD adds the non-standard `optreset' feature, for reinitialisation
 * of `getopt' parsing.  We support this feature, for applications which
 * proclaim their BSD heritage, before including this header; however,
 * to maintain portability, developers are advised to avoid it.
 */
# define optreset  __mingw_optreset
extern int optreset;
#endif
#ifdef __cplusplus
}
#endif
/*
 * POSIX requires the `getopt' API to be specified in `unistd.h';
 * thus, `unistd.h' includes this header.  However, we do not want
 * to expose the `getopt_long' or `getopt_long_only' APIs, when
 * included in this manner.  Thus, close the standard __GETOPT_H__
 * declarations block, and open an additional __GETOPT_LONG_H__
 * specific block, only when *not* __UNISTD_H_SOURCED__, in which
 * to declare the extended API.
 */
#endif /* !defined(__GETOPT_H__) */

#if !defined(__UNISTD_H_SOURCED__) && !defined(__GETOPT_LONG_H__)
#define __GETOPT_LONG_H__

#ifdef __cplusplus
extern "C" {
#endif

enum            /* permitted values for its `has_arg' field...    */
{
  no_argument = 0,          /* option never takes an argument    */
  required_argument,        /* option always requires an argument    */
  optional_argument        /* option may take an argument        */
};

/*
 * parse_long_options --
 *    Parse long options in argc/argv argument vector.
 * Returns -1 if short_too is set and the option does not match long_options.
 */
static int
parse_long_options(char * const *nargv, const char *options,
        const struct option *long_options, int *idx, int short_too)
{
        char *current_argv, *has_equal;
        size_t current_argv_len;
        int i, ambiguous, match;

#define IDENTICAL_INTERPRETATION(_x, _y)                                \
        (long_options[(_x)].has_arg == long_options[(_y)].has_arg &&    \
         long_options[(_x)].flag == long_options[(_y)].flag &&          \
         long_options[(_x)].val == long_options[(_y)].val)

        current_argv = place;
        match = -1;
        ambiguous = 0;

        optind++;

        if ((has_equal = strchr(current_argv, '=')) != NULL) {
                /* argument found (--option=arg) */
                current_argv_len = has_equal - current_argv;
                has_equal++;
        } else
                current_argv_len = strlen(current_argv);

        for (i = 0; long_options[i].name; i++) {
                /* find matching long option */
                if (strncmp(current_argv, long_options[i].name,
                    current_argv_len))
                        continue;

                if (strlen(long_options[i].name) == current_argv_len) {
                        /* exact match */
                        match = i;
                        ambiguous = 0;
                        break;
                }
                /*
                 * If this is a known short option, don't allow
                 * a partial match of a single character.
                 */
                if (short_too && current_argv_len == 1)
                        continue;

                if (match == -1)    /* partial match */
                        match = i;
                else if (!IDENTICAL_INTERPRETATION(i, match))
                        ambiguous = 1;
        }
        if (ambiguous) {
                /* ambiguous abbreviation */
                if (PRINT_ERROR)
                        warnx(ambig, (int)current_argv_len,
                             current_argv);
                optopt = 0;
                return (BADCH);
        }
        if (match != -1) {        /* option found */
                if (long_options[match].has_arg == no_argument
                    && has_equal) {
                        if (PRINT_ERROR)
                                warnx(noarg, (int)current_argv_len,
                                     current_argv);
                        /*
                         * XXX: GNU sets optopt to val regardless of flag
                         */
                        if (long_options[match].flag == NULL)
                                optopt = long_options[match].val;
                        else
                                optopt = 0;
                        return (BADARG);
                }
                if (long_options[match].has_arg == required_argument ||
                    long_options[match].has_arg == optional_argument) {
                        if (has_equal)
                                optarg = has_equal;
                        else if (long_options[match].has_arg ==
                            required_argument) {
                                /*
                                 * optional argument doesn't use next nargv
                                 */
                                optarg = nargv[optind++];
                        }
                }
                if ((long_options[match].has_arg == required_argument)
                    && (optarg == NULL)) {
                        /*
                         * Missing argument; leading ':' indicates no error
                         * should be generated.
                         */
                        if (PRINT_ERROR)
                                warnx(recargstring,
                                    current_argv);
                        /*
                         * XXX: GNU sets optopt to val regardless of flag
                         */
                        if (long_options[match].flag == NULL)
                                optopt = long_options[match].val;
                        else
                                optopt = 0;
                        --optind;
                        return (BADARG);
                }
        } else {            /* unknown option */
                if (short_too) {
                        --optind;
                        return (-1);
                }
                if (PRINT_ERROR)
                        warnx(illoptstring, current_argv);
                optopt = 0;
                return (BADCH);
        }
        if (idx)
                *idx = match;
        if (long_options[match].flag) {
                *long_options[match].flag = long_options[match].val;
                return (0);
        } else
                return (long_options[match].val);
#undef IDENTICAL_INTERPRETATION
}

/*
 * getopt_internal --
 *    Parse argc/argv argument vector.  Called by user level routines.
 */
static int
getopt_internal(int nargc, char * const *nargv, const char *options,
        const struct option *long_options, int *idx, int flags)
{
        char *oli;                /* option letter list index */
        int optchar, short_too;
        static int posixly_correct = -1;

        if (options == NULL)
                return (-1);

        /*
         * XXX Some GNU programs (like cvs) set optind to 0 instead of
         * XXX using optreset.  Work around this braindamage.
         */
        if (optind == 0)
                optind = optreset = 1;

        /*
         * Disable GNU extensions if POSIXLY_CORRECT is set or options
         * string begins with a '+'.
         *
         * CV, 2009-12-14: Check POSIXLY_CORRECT anew if optind == 0 or
         *                 optreset != 0 for GNU compatibility.
         */
        if (posixly_correct == -1 || optreset != 0)
                posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
        if (*options == '-')
                flags |= FLAG_ALLARGS;
        else if (posixly_correct || *options == '+')
                flags &= ~FLAG_PERMUTE;
        if (*options == '+' || *options == '-')
                options++;

        optarg = NULL;
        if (optreset)
                nonopt_start = nonopt_end = -1;
start:
        if (optreset || !*place) {        /* update scanning pointer */
                optreset = 0;
                if (optind >= nargc) {          /* end of argument vector */
                        place = EMSG;
                        if (nonopt_end != -1) {
                                /* do permutation, if we have to */
                                permute_args(nonopt_start, nonopt_end,
                                    optind, nargv);
                                optind -= nonopt_end - nonopt_start;
                        }
                        else if (nonopt_start != -1) {
                                /*
                                 * If we skipped non-options, set optind
                                 * to the first of them.
                                 */
                                optind = nonopt_start;
                        }
                        nonopt_start = nonopt_end = -1;
                        return (-1);
                }
                if (*(place = nargv[optind]) != '-' ||
                    (place[1] == '\0' && strchr(options, '-') == NULL)) {
                        place = EMSG;        /* found non-option */
                        if (flags & FLAG_ALLARGS) {
                                /*
                                 * GNU extension:
                                 * return non-option as argument to option 1
                                 */
                                optarg = nargv[optind++];
                                return (INORDER);
                        }
                        if (!(flags & FLAG_PERMUTE)) {
                                /*
                                 * If no permutation wanted, stop parsing
                                 * at first non-option.
                                 */
                                return (-1);
                        }
                        /* do permutation */
                        if (nonopt_start == -1)
                                nonopt_start = optind;
                        else if (nonopt_end != -1) {
                                permute_args(nonopt_start, nonopt_end,
                                    optind, nargv);
                                nonopt_start = optind -
                                    (nonopt_end - nonopt_start);
                                nonopt_end = -1;
                        }
                        optind++;
                        /* process next argument */
                        goto start;
                }
                if (nonopt_start != -1 && nonopt_end == -1)
                        nonopt_end = optind;

                /*
                 * If we have "-" do nothing, if "--" we are done.
                 */
                if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
                        optind++;
                        place = EMSG;
                        /*
                         * We found an option (--), so if we skipped
                         * non-options, we have to permute.
                         */
                        if (nonopt_end != -1) {
                                permute_args(nonopt_start, nonopt_end,
                                    optind, nargv);
                                optind -= nonopt_end - nonopt_start;
                        }
                        nonopt_start = nonopt_end = -1;
                        return (-1);
                }
        }

        /*
         * Check long options if:
         *  1) we were passed some
         *  2) the arg is not just "-"
         *  3) either the arg starts with -- we are getopt_long_only()
         */
        if (long_options != NULL && place != nargv[optind] &&
            (*place == '-' || (flags & FLAG_LONGONLY))) {
                short_too = 0;
                if (*place == '-')
                        place++;        /* --foo long option */
                else if (*place != ':' && strchr(options, *place) != NULL)
                        short_too = 1;        /* could be short option too */

                optchar = parse_long_options(nargv, options, long_options,
                    idx, short_too);
                if (optchar != -1) {
                        place = EMSG;
                        return (optchar);
                }
        }

        if ((optchar = (int)*place++) == (int)':' ||
            (optchar == (int)'-' && *place != '\0') ||
            (oli = (char*)strchr(options, optchar)) == NULL) {
                /*
                 * If the user specified "-" and  '-' isn't listed in
                 * options, return -1 (non-option) as per POSIX.
                 * Otherwise, it is an unknown option character (or ':').
                 */
                if (optchar == (int)'-' && *place == '\0')
                        return (-1);
                if (!*place)
                        ++optind;
                if (PRINT_ERROR)
                        warnx(illoptchar, optchar);
                optopt = optchar;
                return (BADCH);
        }
        if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
                /* -W long-option */
                if (*place)            /* no space */
                        /* NOTHING */;
                else if (++optind >= nargc) {    /* no arg */
                        place = EMSG;
                        if (PRINT_ERROR)
                                warnx(recargchar, optchar);
                        optopt = optchar;
                        return (BADARG);
                } else                /* white space */
                        place = nargv[optind];
                optchar = parse_long_options(nargv, options, long_options,
                    idx, 0);
                place = EMSG;
                return (optchar);
        }
        if (*++oli != ':') {            /* doesn't take argument */
                if (!*place)
                        ++optind;
        } else {                /* takes (optional) argument */
                optarg = NULL;
                if (*place)            /* no white space */
                        optarg = place;
                else if (oli[1] != ':') {    /* arg not optional */
                        if (++optind >= nargc) {    /* no arg */
                                place = EMSG;
                                if (PRINT_ERROR)
                                        warnx(recargchar, optchar);
                                optopt = optchar;
                                return (BADARG);
                        } else
                                optarg = nargv[optind];
                }
                place = EMSG;
                ++optind;
        }
        /* dump back option letter */
        return (optchar);
}

/*
 * getopt_long --
 *    Parse argc/argv argument vector.
 */
int
getopt_long(int nargc, char * const *nargv, const char *options,
    const struct option *long_options, int *idx)
{

        return (getopt_internal(nargc, nargv, options, long_options, idx,
            FLAG_PERMUTE));
}

/*
 * getopt_long_only --
 *    Parse argc/argv argument vector.
 */
int
getopt_long_only(int nargc, char * const *nargv, const char *options,
    const struct option *long_options, int *idx)
{

        return (getopt_internal(nargc, nargv, options, long_options, idx,
            FLAG_PERMUTE|FLAG_LONGONLY));
}

//extern int getopt_long(int nargc, char * const *nargv, const char *options,
//    const struct option *long_options, int *idx);
//extern int getopt_long_only(int nargc, char * const *nargv, const char *options,
//    const struct option *long_options, int *idx);
/*
 * Previous MinGW implementation had...
 */
#ifndef HAVE_DECL_GETOPT
/*
 * ...for the long form API only; keep this for compatibility.
 */
# define HAVE_DECL_GETOPT    1
#endif

#ifdef __cplusplus
}
#endif

#endif /* !defined(__UNISTD_H_SOURCED__) && !defined(__GETOPT_LONG_H__) */

.output "builds/cmake/IdentifyOS.cmake"
set(CMAKE_OS_NAME ${CMAKE_SYSTEM_NAME})
set(CMAKE_OS_VERSION ${CMAKE_SYSTEM_VERSION})

if (UNIX)
    if (APPLE)
        set (CMAKE_OS_NAME "OSX" CACHE STRING "Operating system name" FORCE)
        execute_process(COMMAND sw_vers -productVersion OUTPUT_VARIABLE CMAKE_OS_VERSION OUTPUT_STRIP_TRAILING_WHITESPACE)
    else (APPLE)
        ## Check for Debian GNU/Linux _______________
        find_file (DEBIAN_FOUND debian_version debconf.conf PATHS /etc)
        if (DEBIAN_FOUND)
            set (CMAKE_OS_NAME "Debian" CACHE STRING "Operating system name" FORCE)
            file (STRINGS "/etc/debian_version" CMAKE_OS_VERSION)
            string (REGEX REPLACE "([0-9]+)(\\\\.[0-9]+)*" "\\\\1" CMAKE_OS_VERSION "${CMAKE_OS_VERSION}")

            ## Extra check for Ubuntu _______________
            find_file (UBUNTU_EXTRA legal issue PATHS /etc)
            if (UBUNTU_EXTRA)
                ## Scan contents of file
                file (STRINGS ${UBUNTU_EXTRA} UBUNTU_FOUND REGEX Ubuntu)
                ## Check result of string search
                if (UBUNTU_FOUND)
                    set (CMAKE_OS_NAME "Ubuntu" CACHE STRING "Operating system name" FORCE)
                    set (DEBIAN_FOUND FALSE)
                endif (UBUNTU_FOUND)
            endif (UBUNTU_EXTRA)
        endif (DEBIAN_FOUND)

        ## Check for Fedora _________________________
        find_file (FEDORA_FOUND fedora-release PATHS /etc)
        if (FEDORA_FOUND)
            set (CMAKE_OS_NAME "Fedora" CACHE STRING "Operating system name" FORCE)
        endif (FEDORA_FOUND)

        ## Check for RedHat _________________________
        find_file (REDHAT_FOUND redhat-release inittab.RH PATHS /etc)
        if (REDHAT_FOUND)
            set (CMAKE_OS_NAME "RedHat" CACHE STRING "Operating system name" FORCE)

            ## Extra check for CentOS _______________
            ## Scan contents of file
            file (STRINGS ${REDHAT_FOUND} CENTOS_FOUND REGEX "CentOS .* ([0-9]+)(\\.[0-9]+)*")
            ## Check result of string search
            if (CENTOS_FOUND)
                set (CMAKE_OS_NAME "CentOS" CACHE STRING "Operating system name" FORCE)
                string (REGEX REPLACE "CentOS .* ([0-9]+)(\\.[0-9]+)+.*" "\\1" CMAKE_OS_VERSION "${CENTOS_FOUND}")
                set (REDHAT_FOUND FALSE)
            endif (CENTOS_FOUND)
        endif (REDHAT_FOUND)
    endif (APPLE)
endif (UNIX)

message(STATUS "- OS Name     ${CMAKE_OS_NAME}")
message(STATUS "- OS Version  ${CMAKE_OS_VERSION}")

.output "packaging/unix/install_script.sh"
#!/usr/bin/env bash

# Checks whether the current user is root or not and make use of 'sudo' if needed.
function _check_sudo {
    if [[ $EUID = 0 ]]
    then
        $@
    else
        echo "WARNING: You need an elevated prompt to install the ingescape library"
        sudo $@
    fi
}

## Initialisation

# Exit on error
set -o errexit

# Exit on unknown variable used
set -o nounset

# Return code for piped sequences is the last command that returned non-zero (we don't have pipes for now)
set -o pipefail

echo "Installing ingescape and its dependencies..."
echo "-----------------------"
_check_sudo cp -rv . /usr/local/

echo ""
echo "Installation completed with success!"

## EOF ##
.
.output "builds/cmake/FindPROTOBUF-C.cmake"
# - Try to find protobuf-c
 # Once done this will define
 #  PROTOBUFC_FOUND - System has libprotobuf-c
 #  PROTOBUFC_INCLUDE_DIRS - The libprotobuf-c include directories
 #  PROTOBUFC_LIBRARIES - The libraries needed to use libprotobuf-c
 #  PROTOBUFC_DEFINITIONS - Compiler switches required for using libprotobuf-c
 #  PROTOBUFC_COMPILER - The protobuf-c compiler
 find_package(PkgConfig)
 pkg_check_modules(PC_PROTOBUFC_QUIET libprotobuf-c)
 set(PROTOBUFC_DEFINITIONS ${PC_PROTOBUFC_CFLAGS_OTHER})
 find_path(PROTOBUFC_INCLUDE_DIR google/protobuf-c/protobuf-c.h
     HINTS ${PC_PROTOBUFC_INCLUDEDIR} ${PC_PROTOBUFC_INCLUDE_DIRS}
     PATH_SUFFIXES libprotobuf-c)
 find_library(PROTOBUFC_LIBRARY NAMES protobuf-c
     HINTS ${PC_PROTOBUFC_LIBDIR}
     ${PC_PROTOBUFC_LIBRARY_DIRS})
 find_program(PROTOCC_EXECUTABLE protoc-c)
 set(PROTOBUFC_LIBRARIES ${PROTOBUFC_LIBRARY})
 set(PROTOBUFC_INCLUDE_DIRS ${PROTOBUFC_INCLUDE_DIR})
 set(PROTOBUFC_COMPILER ${PROTOCC_EXECUTABLE})
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(libprotobuf-c DEFAULT_MSG
     PROTOBUFC_LIBRARY PROTOBUFC_INCLUDE_DIR PROTOBUFC_COMPILER)
 mark_as_advanced(PROTOBUFC PROTOBUFC_INCLUDE_DIR PROTOBUFC_LIBRARY)
 function(PROTOC VAR)
     if (NOT ARGN)
         message(SEND_ERROR "Error: WRAP PROTO called without any proto files")
         return()
     endif(NOT ARGN)
     set(INCL)
     set(${VAR})
     foreach(FIL ${ARGN})
         get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
         get_filename_component(FIL_WE ${FIL} NAME_WE)
         list(APPEND ${VAR} "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb-c.c")
         list(APPEND INCL "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb-c.h")
         add_custom_command(
             OUTPUT ${${VAR}} ${INCL}
             COMMAND  ${PROTOBUFC_COMPILER}
             ARGS --c_out  ${CMAKE_CURRENT_BINARY_DIR} --proto_path ${CMAKE_CURRENT_SOURCE_DIR} ${ABS_FIL}
             DEPENDS ${ABS_FIL}
             COMMENT "Running protocol buffer compiler on ${FIL}"
             VERBATIM
     )
     endforeach(FIL)
     set(${VAR} ${${VAR}} PARENT_SCOPE)
 endfunction(PROTOC VAR)

.
.output "builds/cmake/NSIS.InstallOptions.ini.in"
[Settings]
NumFields=5

[Field 1]
Type=label
Text=By default @CPACK_PACKAGE_INSTALL_DIRECTORY@ does not add its directory to the system PATH.
Left=0
Right=-1
Top=0
Bottom=20

[Field 2]
Type=radiobutton
Text=Do not add @CPACK_PACKAGE_NAME@ to the system PATH
Left=0
Right=-1
Top=30
Bottom=40
State=1

[Field 3]
Type=radiobutton
Text=Add @CPACK_PACKAGE_NAME@ to the system PATH for all users
Left=0
Right=-1
Top=40
Bottom=50
State=0

[Field 4]
Type=radiobutton
Text=Add @CPACK_PACKAGE_NAME@ to the system PATH for current user
Left=0
Right=-1
Top=50
Bottom=60
State=0

[Field 5]
Type=CheckBox
Text=Create @CPACK_PACKAGE_NAME@ Desktop Icon
Left=0
Right=-1
Top=80
Bottom=90
State=0

.output "builds/cmake/NSIS.template.in"
; CPack install script designed for a nmake build

;--------------------------------
; You must define these values

  !define VERSION "@CPACK_PACKAGE_VERSION@"
  !define PATCH  "@CPACK_PACKAGE_VERSION_PATCH@"
  !define INST_DIR "@CPACK_TEMPORARY_DIRECTORY@"

;--------------------------------
;Variables

  Var MUI_TEMP
  Var STARTMENU_FOLDER
  Var SV_ALLUSERS
  Var START_MENU
  Var DO_NOT_ADD_TO_PATH
  Var ADD_TO_PATH_ALL_USERS
  Var ADD_TO_PATH_CURRENT_USER
  Var INSTALL_DESKTOP
  Var IS_DEFAULT_INSTALLDIR
;--------------------------------
;Include Modern UI

  !include "MUI.nsh"

  ;Default installation folder
  InstallDir "@CPACK_NSIS_INSTALL_ROOT@\\@CPACK_PACKAGE_INSTALL_DIRECTORY@"

;--------------------------------
;General

  ;Name and file
  Name "@CPACK_NSIS_PACKAGE_NAME@"
  OutFile "@CPACK_TOPLEVEL_DIRECTORY@/@CPACK_OUTPUT_FILE_NAME@"

  ;Set compression
  SetCompressor @CPACK_NSIS_COMPRESSOR@

  ;Require administrator access
  RequestExecutionLevel admin

@CPACK_NSIS_DEFINES@

  !include Sections.nsh

;--- Component support macros: ---
; The code for the add/remove functionality is from:
;   http://nsis.sourceforge.net/Add/Remove_Functionality
; It has been modified slightly and extended to provide
; inter-component dependencies.
Var AR_SecFlags
Var AR_RegFlags
@CPACK_NSIS_SECTION_SELECTED_VARS@

; Loads the "selected" flag for the section named SecName into the
; variable VarName.
!macro LoadSectionSelectedIntoVar SecName VarName
 SectionGetFlags ${${SecName}} $${VarName}
 IntOp $${VarName} $${VarName} & ${SF_SELECTED}  ;Turn off all other bits
!macroend

; Loads the value of a variable... can we get around this?
!macro LoadVar VarName
  IntOp $R0 0 + $${VarName}
!macroend

; Sets the value of a variable
!macro StoreVar VarName IntValue
  IntOp $${VarName} 0 + ${IntValue}
!macroend

!macro InitSection SecName
  ;  This macro reads component installed flag from the registry and
  ;changes checked state of the section on the components page.
  ;Input: section index constant name specified in Section command.

  ClearErrors
  ;Reading component status from registry
  ReadRegDWORD $AR_RegFlags HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@\\Components\\${SecName}" "Installed"
  IfErrors "default_${SecName}"
    ;Status will stay default if registry value not found
    ;(component was never installed)
  IntOp $AR_RegFlags $AR_RegFlags & ${SF_SELECTED} ;Turn off all other bits
  SectionGetFlags ${${SecName}} $AR_SecFlags  ;Reading default section flags
  IntOp $AR_SecFlags $AR_SecFlags & 0xFFFE  ;Turn lowest (enabled) bit off
  IntOp $AR_SecFlags $AR_RegFlags | $AR_SecFlags      ;Change lowest bit

  ; Note whether this component was installed before
  !insertmacro StoreVar ${SecName}_was_installed $AR_RegFlags
  IntOp $R0 $AR_RegFlags & $AR_RegFlags

  ;Writing modified flags
  SectionSetFlags ${${SecName}} $AR_SecFlags

 "default_${SecName}:"
 !insertmacro LoadSectionSelectedIntoVar ${SecName} ${SecName}_selected
!macroend

!macro FinishSection SecName
  ;  This macro reads section flag set by user and removes the section
  ;if it is not selected.
  ;Then it writes component installed flag to registry
  ;Input: section index constant name specified in Section command.

  SectionGetFlags ${${SecName}} $AR_SecFlags  ;Reading section flags
  ;Checking lowest bit:
  IntOp $AR_SecFlags $AR_SecFlags & ${SF_SELECTED}
  IntCmp $AR_SecFlags 1 "leave_${SecName}"
    ;Section is not selected:
    ;Calling Section uninstall macro and writing zero installed flag
    !insertmacro "Remove_${${SecName}}"
    WriteRegDWORD HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@\\Components\\${SecName}" \\
  "Installed" 0
    Goto "exit_${SecName}"

 "leave_${SecName}:"
    ;Section is selected:
    WriteRegDWORD HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@\\Components\\${SecName}" \\
  "Installed" 1

 "exit_${SecName}:"
!macroend

!macro RemoveSection_CPack SecName
  ;  This macro is used to call section's Remove_... macro
  ;from the uninstaller.
  ;Input: section index constant name specified in Section command.

  !insertmacro "Remove_${${SecName}}"
!macroend

; Determine whether the selection of SecName changed
!macro MaybeSelectionChanged SecName
  !insertmacro LoadVar ${SecName}_selected
  SectionGetFlags ${${SecName}} $R1
  IntOp $R1 $R1 & ${SF_SELECTED} ;Turn off all other bits

  ; See if the status has changed:
  IntCmp $R0 $R1 "${SecName}_unchanged"
  !insertmacro LoadSectionSelectedIntoVar ${SecName} ${SecName}_selected

  IntCmp $R1 ${SF_SELECTED} "${SecName}_was_selected"
  !insertmacro "Deselect_required_by_${SecName}"
  goto "${SecName}_unchanged"

  "${SecName}_was_selected:"
  !insertmacro "Select_${SecName}_depends"

  "${SecName}_unchanged:"
!macroend
;--- End of Add/Remove macros ---

;--------------------------------
;Interface Settings

  !define MUI_HEADERIMAGE
  !define MUI_ABORTWARNING

;----------------------------------------
; based upon a script of "Written by KiCHiK 2003-01-18 05:57:02"
;----------------------------------------
!verbose 3
!include "WinMessages.NSH"
!verbose 4
;====================================================
; get_NT_environment
;     Returns: the selected environment
;     Output : head of the stack
;====================================================
!macro select_NT_profile UN
Function ${UN}select_NT_profile
   StrCmp $ADD_TO_PATH_ALL_USERS "1" 0 environment_single
      DetailPrint "Selected environment for all users"
      Push "all"
      Return
   environment_single:
      DetailPrint "Selected environment for current user only."
      Push "current"
      Return
FunctionEnd
!macroend
!insertmacro select_NT_profile ""
!insertmacro select_NT_profile "un."
;----------------------------------------------------
!define NT_current_env 'HKCU "Environment"'
!define NT_all_env     'HKLM "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"'

!ifndef WriteEnvStr_RegKey
  !ifdef ALL_USERS
    !define WriteEnvStr_RegKey \\
       'HKLM "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment"'
  !else
    !define WriteEnvStr_RegKey 'HKCU "Environment"'
  !endif
!endif

; AddToPath - Adds the given dir to the search path.
;        Input - head of the stack
;        Note - Win9x systems requires reboot

Function AddToPath
  Exch $0
  Push $1
  Push $2
  Push $3

  # don't add if the path doesn't exist
  IfFileExists "$0\\*.*" "" AddToPath_done

  ReadEnvStr $1 PATH
  ; if the path is too long for a NSIS variable NSIS will return a 0
  ; length string.  If we find that, then warn and skip any path
  ; modification as it will trash the existing path.
  StrLen $2 $1
  IntCmp $2 0 CheckPathLength_ShowPathWarning CheckPathLength_Done CheckPathLength_Done
    CheckPathLength_ShowPathWarning:
    Messagebox MB_OK|MB_ICONEXCLAMATION "Warning! PATH too long installer unable to modify PATH!"
    Goto AddToPath_done
  CheckPathLength_Done:
  Push "$1;"
  Push "$0;"
  Call StrStr
  Pop $2
  StrCmp $2 "" "" AddToPath_done
  Push "$1;"
  Push "$0\\;"
  Call StrStr
  Pop $2
  StrCmp $2 "" "" AddToPath_done
  GetFullPathName /SHORT $3 $0
  Push "$1;"
  Push "$3;"
  Call StrStr
  Pop $2
  StrCmp $2 "" "" AddToPath_done
  Push "$1;"
  Push "$3\\;"
  Call StrStr
  Pop $2
  StrCmp $2 "" "" AddToPath_done

  Call IsNT
  Pop $1
  StrCmp $1 1 AddToPath_NT
    ; Not on NT
    StrCpy $1 $WINDIR 2
    FileOpen $1 "$1\\autoexec.bat" a
    FileSeek $1 -1 END
    FileReadByte $1 $2
    IntCmp $2 26 0 +2 +2 # DOS EOF
      FileSeek $1 -1 END # write over EOF
    FileWrite $1 "$\\r$\\nSET PATH=%PATH%;$3$\\r$\\n"
    FileClose $1
    SetRebootFlag true
    Goto AddToPath_done

  AddToPath_NT:
    StrCmp $ADD_TO_PATH_ALL_USERS "1" ReadAllKey
      ReadRegStr $1 ${NT_current_env} "PATH"
      Goto DoTrim
    ReadAllKey:
      ReadRegStr $1 ${NT_all_env} "PATH"
    DoTrim:
    StrCmp $1 "" AddToPath_NTdoIt
      Push $1
      Call Trim
      Pop $1
      StrCpy $0 "$1;$0"
    AddToPath_NTdoIt:
      StrCmp $ADD_TO_PATH_ALL_USERS "1" WriteAllKey
        WriteRegExpandStr ${NT_current_env} "PATH" $0
        Goto DoSend
      WriteAllKey:
        WriteRegExpandStr ${NT_all_env} "PATH" $0
      DoSend:
      SendMessage ${HWND_BROADCAST} ${WM_WININICHANGE} 0 "STR:Environment" /TIMEOUT=5000

  AddToPath_done:
    Pop $3
    Pop $2
    Pop $1
    Pop $0
FunctionEnd


; RemoveFromPath - Remove a given dir from the path
;     Input: head of the stack

Function un.RemoveFromPath
  Exch $0
  Push $1
  Push $2
  Push $3
  Push $4
  Push $5
  Push $6

  IntFmt $6 "%c" 26 # DOS EOF

  Call un.IsNT
  Pop $1
  StrCmp $1 1 unRemoveFromPath_NT
    ; Not on NT
    StrCpy $1 $WINDIR 2
    FileOpen $1 "$1\\autoexec.bat" r
    GetTempFileName $4
    FileOpen $2 $4 w
    GetFullPathName /SHORT $0 $0
    StrCpy $0 "SET PATH=%PATH%;$0"
    Goto unRemoveFromPath_dosLoop

    unRemoveFromPath_dosLoop:
      FileRead $1 $3
      StrCpy $5 $3 1 -1 # read last char
      StrCmp $5 $6 0 +2 # if DOS EOF
        StrCpy $3 $3 -1 # remove DOS EOF so we can compare
      StrCmp $3 "$0$\\r$\\n" unRemoveFromPath_dosLoopRemoveLine
      StrCmp $3 "$0$\\n" unRemoveFromPath_dosLoopRemoveLine
      StrCmp $3 "$0" unRemoveFromPath_dosLoopRemoveLine
      StrCmp $3 "" unRemoveFromPath_dosLoopEnd
      FileWrite $2 $3
      Goto unRemoveFromPath_dosLoop
      unRemoveFromPath_dosLoopRemoveLine:
        SetRebootFlag true
        Goto unRemoveFromPath_dosLoop

    unRemoveFromPath_dosLoopEnd:
      FileClose $2
      FileClose $1
      StrCpy $1 $WINDIR 2
      Delete "$1\\autoexec.bat"
      CopyFiles /SILENT $4 "$1\\autoexec.bat"
      Delete $4
      Goto unRemoveFromPath_done

  unRemoveFromPath_NT:
    StrCmp $ADD_TO_PATH_ALL_USERS "1" unReadAllKey
      ReadRegStr $1 ${NT_current_env} "PATH"
      Goto unDoTrim
    unReadAllKey:
      ReadRegStr $1 ${NT_all_env} "PATH"
    unDoTrim:
    StrCpy $5 $1 1 -1 # copy last char
    StrCmp $5 ";" +2 # if last char != ;
      StrCpy $1 "$1;" # append ;
    Push $1
    Push "$0;"
    Call un.StrStr ; Find `$0;` in $1
    Pop $2 ; pos of our dir
    StrCmp $2 "" unRemoveFromPath_done
      ; else, it is in path
      # $0 - path to add
      # $1 - path var
      StrLen $3 "$0;"
      StrLen $4 $2
      StrCpy $5 $1 -$4 # $5 is now the part before the path to remove
      StrCpy $6 $2 "" $3 # $6 is now the part after the path to remove
      StrCpy $3 $5$6

      StrCpy $5 $3 1 -1 # copy last char
      StrCmp $5 ";" 0 +2 # if last char == ;
        StrCpy $3 $3 -1 # remove last char

      StrCmp $ADD_TO_PATH_ALL_USERS "1" unWriteAllKey
        WriteRegExpandStr ${NT_current_env} "PATH" $3
        Goto unDoSend
      unWriteAllKey:
        WriteRegExpandStr ${NT_all_env} "PATH" $3
      unDoSend:
      SendMessage ${HWND_BROADCAST} ${WM_WININICHANGE} 0 "STR:Environment" /TIMEOUT=5000

  unRemoveFromPath_done:
    Pop $6
    Pop $5
    Pop $4
    Pop $3
    Pop $2
    Pop $1
    Pop $0
FunctionEnd

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Uninstall sutff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

###########################################
#            Utility Functions            #
###########################################

;====================================================
; IsNT - Returns 1 if the current system is NT, 0
;        otherwise.
;     Output: head of the stack
;====================================================
; IsNT
; no input
; output, top of the stack = 1 if NT or 0 if not
;
; Usage:
;   Call IsNT
;   Pop $R0
;  ($R0 at this point is 1 or 0)

!macro IsNT un
Function ${un}IsNT
  Push $0
  ReadRegStr $0 HKLM "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion" CurrentVersion
  StrCmp $0 "" 0 IsNT_yes
  ; we are not NT.
  Pop $0
  Push 0
  Return

  IsNT_yes:
    ; NT!!!
    Pop $0
    Push 1
FunctionEnd
!macroend
!insertmacro IsNT ""
!insertmacro IsNT "un."

; StrStr
; input, top of stack = string to search for
;        top of stack-1 = string to search in
; output, top of stack (replaces with the portion of the string remaining)
; modifies no other variables.
;
; Usage:
;   Push "this is a long ass string"
;   Push "ass"
;   Call StrStr
;   Pop $R0
;  ($R0 at this point is "ass string")

!macro StrStr un
Function ${un}StrStr
Exch $R1 ; st=haystack,old$R1, $R1=needle
  Exch    ; st=old$R1,haystack
  Exch $R2 ; st=old$R1,old$R2, $R2=haystack
  Push $R3
  Push $R4
  Push $R5
  StrLen $R3 $R1
  StrCpy $R4 0
  ; $R1=needle
  ; $R2=haystack
  ; $R3=len(needle)
  ; $R4=cnt
  ; $R5=tmp
  loop:
    StrCpy $R5 $R2 $R3 $R4
    StrCmp $R5 $R1 done
    StrCmp $R5 "" done
    IntOp $R4 $R4 + 1
    Goto loop
done:
  StrCpy $R1 $R2 "" $R4
  Pop $R5
  Pop $R4
  Pop $R3
  Pop $R2
  Exch $R1
FunctionEnd
!macroend
!insertmacro StrStr ""
!insertmacro StrStr "un."

Function Trim ; Added by Pelaca
    Exch $R1
    Push $R2
Loop:
    StrCpy $R2 "$R1" 1 -1
    StrCmp "$R2" " " RTrim
    StrCmp "$R2" "$\\n" RTrim
    StrCmp "$R2" "$\\r" RTrim
    StrCmp "$R2" ";" RTrim
    GoTo Done
RTrim:
    StrCpy $R1 "$R1" -1
    Goto Loop
Done:
    Pop $R2
    Exch $R1
FunctionEnd

Function ConditionalAddToRegisty
  Pop $0
  Pop $1
  StrCmp "$0" "" ConditionalAddToRegisty_EmptyString
    WriteRegStr SHCTX "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@" \\
    "$1" "$0"
    ;MessageBox MB_OK "Set Registry: '$1' to '$0'"
    DetailPrint "Set install registry entry: '$1' to '$0'"
  ConditionalAddToRegisty_EmptyString:
FunctionEnd

;--------------------------------

!ifdef CPACK_USES_DOWNLOAD
Function DownloadFile
    IfFileExists $INSTDIR\\* +2
    CreateDirectory $INSTDIR
    Pop $0

    ; Skip if already downloaded
    IfFileExists $INSTDIR\\$0 0 +2
    Return

    StrCpy $1 "@CPACK_DOWNLOAD_SITE@"

  try_again:
    NSISdl::download "$1/$0" "$INSTDIR\\$0"

    Pop $1
    StrCmp $1 "success" success
    StrCmp $1 "Cancelled" cancel
    MessageBox MB_OK "Download failed: $1"
  cancel:
    Return
  success:
FunctionEnd
!endif

;--------------------------------
; Installation types
@CPACK_NSIS_INSTALLATION_TYPES@

;--------------------------------
; Component sections
@CPACK_NSIS_COMPONENT_SECTIONS@

;--------------------------------
; Define some macro setting for the gui
@CPACK_NSIS_INSTALLER_MUI_ICON_CODE@
@CPACK_NSIS_INSTALLER_ICON_CODE@
@CPACK_NSIS_INSTALLER_MUI_WELCOMEFINISH_CODE@
@CPACK_NSIS_INSTALLER_MUI_UNWELCOMEFINISH_CODE@
@CPACK_NSIS_INSTALLER_MUI_COMPONENTS_DESC@
@CPACK_NSIS_INSTALLER_MUI_FINISHPAGE_RUN_CODE@

;--------------------------------
;Pages
  !insertmacro MUI_PAGE_WELCOME

  !insertmacro MUI_PAGE_LICENSE "@CPACK_RESOURCE_FILE_LICENSE@"
  Page custom InstallOptionsPage
  !insertmacro MUI_PAGE_DIRECTORY

  ;Start Menu Folder Page Configuration
  !define MUI_STARTMENUPAGE_REGISTRY_ROOT "SHCTX"
  !define MUI_STARTMENUPAGE_REGISTRY_KEY "Software\\@CPACK_PACKAGE_VENDOR@\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@"
  !define MUI_STARTMENUPAGE_REGISTRY_VALUENAME "Start Menu Folder"
  !define MUI_STARTMENUPAGE_DEFAULTFOLDER "Ingescape"
  !insertmacro MUI_PAGE_STARTMENU Application $STARTMENU_FOLDER

  @CPACK_NSIS_PAGE_COMPONENTS@

  !insertmacro MUI_PAGE_INSTFILES
  !insertmacro MUI_PAGE_FINISH

  !insertmacro MUI_UNPAGE_CONFIRM
  !insertmacro MUI_UNPAGE_INSTFILES

;--------------------------------
;Languages

  !insertmacro MUI_LANGUAGE "English" ;first language is the default language
  !insertmacro MUI_LANGUAGE "Albanian"
  !insertmacro MUI_LANGUAGE "Arabic"
  !insertmacro MUI_LANGUAGE "Basque"
  !insertmacro MUI_LANGUAGE "Belarusian"
  !insertmacro MUI_LANGUAGE "Bosnian"
  !insertmacro MUI_LANGUAGE "Breton"
  !insertmacro MUI_LANGUAGE "Bulgarian"
  !insertmacro MUI_LANGUAGE "Croatian"
  !insertmacro MUI_LANGUAGE "Czech"
  !insertmacro MUI_LANGUAGE "Danish"
  !insertmacro MUI_LANGUAGE "Dutch"
  !insertmacro MUI_LANGUAGE "Estonian"
  !insertmacro MUI_LANGUAGE "Farsi"
  !insertmacro MUI_LANGUAGE "Finnish"
  !insertmacro MUI_LANGUAGE "French"
  !insertmacro MUI_LANGUAGE "German"
  !insertmacro MUI_LANGUAGE "Greek"
  !insertmacro MUI_LANGUAGE "Hebrew"
  !insertmacro MUI_LANGUAGE "Hungarian"
  !insertmacro MUI_LANGUAGE "Icelandic"
  !insertmacro MUI_LANGUAGE "Indonesian"
  !insertmacro MUI_LANGUAGE "Irish"
  !insertmacro MUI_LANGUAGE "Italian"
  !insertmacro MUI_LANGUAGE "Japanese"
  !insertmacro MUI_LANGUAGE "Korean"
  !insertmacro MUI_LANGUAGE "Kurdish"
  !insertmacro MUI_LANGUAGE "Latvian"
  !insertmacro MUI_LANGUAGE "Lithuanian"
  !insertmacro MUI_LANGUAGE "Luxembourgish"
  !insertmacro MUI_LANGUAGE "Macedonian"
  !insertmacro MUI_LANGUAGE "Malay"
  !insertmacro MUI_LANGUAGE "Mongolian"
  !insertmacro MUI_LANGUAGE "Norwegian"
  !insertmacro MUI_LANGUAGE "Polish"
  !insertmacro MUI_LANGUAGE "Portuguese"
  !insertmacro MUI_LANGUAGE "PortugueseBR"
  !insertmacro MUI_LANGUAGE "Romanian"
  !insertmacro MUI_LANGUAGE "Russian"
  !insertmacro MUI_LANGUAGE "Serbian"
  !insertmacro MUI_LANGUAGE "SerbianLatin"
  !insertmacro MUI_LANGUAGE "SimpChinese"
  !insertmacro MUI_LANGUAGE "Slovak"
  !insertmacro MUI_LANGUAGE "Slovenian"
  !insertmacro MUI_LANGUAGE "Spanish"
  !insertmacro MUI_LANGUAGE "Swedish"
  !insertmacro MUI_LANGUAGE "Thai"
  !insertmacro MUI_LANGUAGE "TradChinese"
  !insertmacro MUI_LANGUAGE "Turkish"
  !insertmacro MUI_LANGUAGE "Ukrainian"
  !insertmacro MUI_LANGUAGE "Welsh"


;--------------------------------
;Reserve Files

  ;These files should be inserted before other files in the data block
  ;Keep these lines before any File command
  ;Only for solid compression (by default, solid compression is enabled for BZIP2 and LZMA)

  ReserveFile "NSIS.InstallOptions.ini"
  !insertmacro MUI_RESERVEFILE_INSTALLOPTIONS

;--------------------------------
;Installer Sections

Section "-Core installation"
  ;Use the entire tree produced by the INSTALL target.  Keep the
  ;list of directories here in sync with the RMDir commands below.
  SetOutPath "$INSTDIR"
  @CPACK_NSIS_EXTRA_PREINSTALL_COMMANDS@
  @CPACK_NSIS_FULL_INSTALL@

  ;Store installation folder
  WriteRegStr SHCTX "Software\\@CPACK_PACKAGE_VENDOR@\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@" "" $INSTDIR

  ;Create uninstaller
  WriteUninstaller "$INSTDIR\\Uninstall @CPACK_PACKAGE_NAME@.exe"
  Push "DisplayName"
  Push "@CPACK_NSIS_DISPLAY_NAME@"
  Call ConditionalAddToRegisty
  Push "DisplayVersion"
  Push "@CPACK_PACKAGE_VERSION@"
  Call ConditionalAddToRegisty
  Push "Publisher"
  Push "@CPACK_PACKAGE_VENDOR@"
  Call ConditionalAddToRegisty
  Push "UninstallString"
  Push "$INSTDIR\\Uninstall @CPACK_PACKAGE_NAME@.exe"
  Call ConditionalAddToRegisty
  Push "NoRepair"
  Push "1"
  Call ConditionalAddToRegisty

  !ifdef CPACK_NSIS_ADD_REMOVE
  ;Create add/remove functionality
  Push "ModifyPath"
  Push "$INSTDIR\\AddRemove.exe"
  Call ConditionalAddToRegisty
  !else
  Push "NoModify"
  Push "1"
  Call ConditionalAddToRegisty
  !endif

  ; Optional registration
  Push "DisplayIcon"
  Push "$INSTDIR\\@CPACK_NSIS_INSTALLED_ICON_NAME@"
  Call ConditionalAddToRegisty
  Push "HelpLink"
  Push "@CPACK_NSIS_HELP_LINK@"
  Call ConditionalAddToRegisty
  Push "URLInfoAbout"
  Push "@CPACK_NSIS_URL_INFO_ABOUT@"
  Call ConditionalAddToRegisty
  Push "Contact"
  Push "@CPACK_NSIS_CONTACT@"
  Call ConditionalAddToRegisty
  !insertmacro MUI_INSTALLOPTIONS_READ $INSTALL_DESKTOP "NSIS.InstallOptions.ini" "Field 5" "State"
  !insertmacro MUI_STARTMENU_WRITE_BEGIN Application

  ;Create shortcuts
  CreateDirectory "$SMPROGRAMS\\$STARTMENU_FOLDER"
  CreateDirectory "$SMPROGRAMS\\$STARTMENU_FOLDER\\Uninstall"
@CPACK_NSIS_CREATE_ICONS@
@CPACK_NSIS_CREATE_ICONS_EXTRA@
  CreateShortCut "$SMPROGRAMS\\$STARTMENU_FOLDER\\Uninstall\\Uninstall @CPACK_PACKAGE_NAME@.lnk" "$INSTDIR\\Uninstall @CPACK_PACKAGE_NAME@.exe"

  ;Read a value from an InstallOptions INI file
  !insertmacro MUI_INSTALLOPTIONS_READ $DO_NOT_ADD_TO_PATH "NSIS.InstallOptions.ini" "Field 2" "State"
  !insertmacro MUI_INSTALLOPTIONS_READ $ADD_TO_PATH_ALL_USERS "NSIS.InstallOptions.ini" "Field 3" "State"
  !insertmacro MUI_INSTALLOPTIONS_READ $ADD_TO_PATH_CURRENT_USER "NSIS.InstallOptions.ini" "Field 4" "State"

  ; Write special uninstall registry entries
  Push "StartMenu"
  Push "$STARTMENU_FOLDER"
  Call ConditionalAddToRegisty
  Push "DoNotAddToPath"
  Push "$DO_NOT_ADD_TO_PATH"
  Call ConditionalAddToRegisty
  Push "AddToPathAllUsers"
  Push "$ADD_TO_PATH_ALL_USERS"
  Call ConditionalAddToRegisty
  Push "AddToPathCurrentUser"
  Push "$ADD_TO_PATH_CURRENT_USER"
  Call ConditionalAddToRegisty
  Push "InstallToDesktop"
  Push "$INSTALL_DESKTOP"
  Call ConditionalAddToRegisty

  !insertmacro MUI_STARTMENU_WRITE_END

@CPACK_NSIS_EXTRA_INSTALL_COMMANDS@

SectionEnd

Section "-Add to path"
  Push $INSTDIR\\bin
  StrCmp "@CPACK_NSIS_MODIFY_PATH@" "ON" 0 doNotAddToPath
  StrCmp $DO_NOT_ADD_TO_PATH "1" doNotAddToPath 0
    Call AddToPath
  doNotAddToPath:
SectionEnd

;--------------------------------
; Create custom pages
Function InstallOptionsPage
  !insertmacro MUI_HEADER_TEXT "Install Options" "Choose options for installing @CPACK_NSIS_PACKAGE_NAME@"
  !insertmacro MUI_INSTALLOPTIONS_DISPLAY "NSIS.InstallOptions.ini"

FunctionEnd

;--------------------------------
; determine admin versus local install
Function un.onInit

  ClearErrors
  UserInfo::GetName
  IfErrors noLM
  Pop $0
  UserInfo::GetAccountType
  Pop $1
  StrCmp $1 "Admin" 0 +3
    SetShellVarContext all
    ;MessageBox MB_OK 'User "$0" is in the Admin group'
    Goto done
  StrCmp $1 "Power" 0 +3
    SetShellVarContext all
    ;MessageBox MB_OK 'User "$0" is in the Power Users group'
    Goto done

  noLM:
    ;Get installation folder from registry if available

  done:

FunctionEnd

;--- Add/Remove callback functions: ---
!macro SectionList MacroName
  ;This macro used to perform operation on multiple sections.
  ;List all of your components in following manner here.
@CPACK_NSIS_COMPONENT_SECTION_LIST@
!macroend

Section -FinishComponents
  ;Removes unselected components and writes component status to registry
  !insertmacro SectionList "FinishSection"

!ifdef CPACK_NSIS_ADD_REMOVE
  ; Get the name of the installer executable
  System::Call 'kernel32::GetModuleFileNameA(i 0, t .R0, i 1024) i r1'
  StrCpy $R3 $R0

  ; Strip off the last 13 characters, to see if we have AddRemove.exe
  StrLen $R1 $R0
  IntOp $R1 $R0 - 13
  StrCpy $R2 $R0 13 $R1
  StrCmp $R2 "AddRemove.exe" addremove_installed

  ; We're not running AddRemove.exe, so install it
  CopyFiles $R3 $INSTDIR\\AddRemove.exe

  addremove_installed:
!endif
SectionEnd
;--- End of Add/Remove callback functions ---

;--------------------------------
; Component dependencies
Function .onSelChange
  !insertmacro SectionList MaybeSelectionChanged
FunctionEnd

;--------------------------------
;Uninstaller Section

Section "Uninstall"
  ReadRegStr $START_MENU SHCTX \\
   "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@" "StartMenu"
  ;MessageBox MB_OK "Start menu is in: $START_MENU"
  ReadRegStr $DO_NOT_ADD_TO_PATH SHCTX \\
    "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@" "DoNotAddToPath"
  ReadRegStr $ADD_TO_PATH_ALL_USERS SHCTX \\
    "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@" "AddToPathAllUsers"
  ReadRegStr $ADD_TO_PATH_CURRENT_USER SHCTX \\
    "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@" "AddToPathCurrentUser"
  ;MessageBox MB_OK "Add to path: $DO_NOT_ADD_TO_PATH all users: $ADD_TO_PATH_ALL_USERS"
  ReadRegStr $INSTALL_DESKTOP SHCTX \\
    "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@" "InstallToDesktop"
  ;MessageBox MB_OK "Install to desktop: $INSTALL_DESKTOP "

@CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS@

  ;Remove files we installed.
  ;Keep the list of directories here in sync with the File commands above.
@CPACK_NSIS_DELETE_FILES@
@CPACK_NSIS_DELETE_DIRECTORIES@

!ifdef CPACK_NSIS_ADD_REMOVE
  ;Remove the add/remove program
  Delete "$INSTDIR\\AddRemove.exe"
!endif

  ;Remove the uninstaller itself.
  Delete "$INSTDIR\\Uninstall @CPACK_PACKAGE_NAME@.exe"
  DeleteRegKey SHCTX "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@"

  ;Remove the installation directory if it is empty.
  RMDir "$INSTDIR"

  ; Remove the registry entries.
  DeleteRegKey SHCTX "Software\\@CPACK_PACKAGE_VENDOR@\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@"

  ; Removes all optional components
  !insertmacro SectionList "RemoveSection_CPack"

  !insertmacro MUI_STARTMENU_GETFOLDER Application $MUI_TEMP

  Delete "$SMPROGRAMS\\$MUI_TEMP\\Uninstall\\Uninstall @CPACK_PACKAGE_NAME@.lnk"
  RMDir "$SMPROGRAMS\\$MUI_TEMP\\Uninstall"
@CPACK_NSIS_DELETE_ICONS@
@CPACK_NSIS_DELETE_ICONS_EXTRA@

  ;Delete empty start menu parent directories
  StrCpy $MUI_TEMP "$SMPROGRAMS\\$MUI_TEMP"

  startMenuDeleteLoop:
    ClearErrors
    RMDir $MUI_TEMP
    GetFullPathName $MUI_TEMP "$MUI_TEMP\\.."

    IfErrors startMenuDeleteLoopDone

    StrCmp "$MUI_TEMP" "$SMPROGRAMS" startMenuDeleteLoopDone startMenuDeleteLoop
  startMenuDeleteLoopDone:

  ; If the user changed the shortcut, then untinstall may not work. This should
  ; try to fix it.
  StrCpy $MUI_TEMP "$START_MENU"
  Delete "$SMPROGRAMS\\$MUI_TEMP\\Uninstall\\Uninstall @CPACK_PACKAGE_NAME@.lnk"
  RMDir "$SMPROGRAMS\\$MUI_TEMP\\Uninstall"
@CPACK_NSIS_DELETE_ICONS_EXTRA@

  ;Delete empty start menu parent directories
  StrCpy $MUI_TEMP "$SMPROGRAMS\\$MUI_TEMP"

  secondStartMenuDeleteLoop:
    ClearErrors
    RMDir $MUI_TEMP
    GetFullPathName $MUI_TEMP "$MUI_TEMP\\.."

    IfErrors secondStartMenuDeleteLoopDone

    StrCmp "$MUI_TEMP" "$SMPROGRAMS" secondStartMenuDeleteLoopDone secondStartMenuDeleteLoop
  secondStartMenuDeleteLoopDone:

  DeleteRegKey /ifempty SHCTX "Software\\@CPACK_PACKAGE_VENDOR@\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@"

  Push $INSTDIR\\bin
  StrCmp $DO_NOT_ADD_TO_PATH_ "1" doNotRemoveFromPath 0
    Call un.RemoveFromPath
  doNotRemoveFromPath:
SectionEnd

;--------------------------------
; determine admin versus local install
; Is install for "AllUsers" or "JustMe"?
; Default to "JustMe" - set to "AllUsers" if admin or on Win9x
; This function is used for the very first "custom page" of the installer.
; This custom page does not show up visibly, but it executes prior to the
; first visible page and sets up $INSTDIR properly...
; Choose different default installation folder based on SV_ALLUSERS...
; "Program Files" for AllUsers, "My Documents" for JustMe...

Function .onInit
  StrCmp "@CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL@" "ON" 0 inst

  ReadRegStr $0 HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@" "UninstallString"
  StrCmp $0 "" inst

  MessageBox MB_YESNOCANCEL|MB_ICONEXCLAMATION \\
  "@CPACK_NSIS_PACKAGE_NAME@ is already installed. $\\n$\\nDo you want to uninstall the old version before installing the new one?" \\
  /SD IDYES IDYES uninst IDNO inst
  Abort

;Run the uninstaller
uninst:
  ClearErrors
  StrLen $2 "\\Uninstall @CPACK_PACKAGE_NAME@.exe"
  StrCpy $3 $0 -$2 # remove "\\Uninstall @CPACK_PACKAGE_NAME@.exe" from UninstallString to get path
  ExecWait '"$0" /S _?=$3' ;Do not copy the uninstaller to a temp file

  IfErrors uninst_failed inst
uninst_failed:
  MessageBox MB_OK|MB_ICONSTOP "Uninstall failed."
  Abort


inst:
  ; Reads components status for registry
  !insertmacro SectionList "InitSection"

  ; check to see if /D has been used to change
  ; the install directory by comparing it to the
  ; install directory that is expected to be the
  ; default
  StrCpy $IS_DEFAULT_INSTALLDIR 0
  StrCmp "$INSTDIR" "@CPACK_NSIS_INSTALL_ROOT@\\@CPACK_PACKAGE_INSTALL_DIRECTORY@" 0 +2
    StrCpy $IS_DEFAULT_INSTALLDIR 1

  StrCpy $SV_ALLUSERS "JustMe"
  ; if default install dir then change the default
  ; if it is installed for JustMe
  StrCmp "$IS_DEFAULT_INSTALLDIR" "1" 0 +2
    StrCpy $INSTDIR "$DOCUMENTS\\@CPACK_PACKAGE_INSTALL_DIRECTORY@"

  ClearErrors
  UserInfo::GetName
  IfErrors noLM
  Pop $0
  UserInfo::GetAccountType
  Pop $1
  StrCmp $1 "Admin" 0 +4
    SetShellVarContext all
    ;MessageBox MB_OK 'User "$0" is in the Admin group'
    StrCpy $SV_ALLUSERS "AllUsers"
    Goto done
  StrCmp $1 "Power" 0 +4
    SetShellVarContext all
    ;MessageBox MB_OK 'User "$0" is in the Power Users group'
    StrCpy $SV_ALLUSERS "AllUsers"
    Goto done

  noLM:
    StrCpy $SV_ALLUSERS "AllUsers"
    ;Get installation folder from registry if available

  done:
  StrCmp $SV_ALLUSERS "AllUsers" 0 +3
    StrCmp "$IS_DEFAULT_INSTALLDIR" "1" 0 +2
      StrCpy $INSTDIR "@CPACK_NSIS_INSTALL_ROOT@\\@CPACK_PACKAGE_INSTALL_DIRECTORY@"

  StrCmp "@CPACK_NSIS_MODIFY_PATH@" "ON" 0 noOptionsPage
    !insertmacro MUI_INSTALLOPTIONS_EXTRACT "NSIS.InstallOptions.ini"

  noOptionsPage:
FunctionEnd

.endtemplate
